接口没有继承 Object类：

> 如果一个接口没有直接顶级父接口，除非在该接口中明确的声明了方法，则会隐含得声明一套和Object中的方法签名完全一样的方法，并且，如果该接口明确声明一个和Object中用final方法一样的，则会报编译时异常。

#### object类的方法

```java
- native 方法
    - registerNatives()
    - getClass()
    - hashCode()
    - clone()
    - notify()/notifyAll()
    - wait()
- 其他 方法
    - equals(Object var1)
    - toString()
    
```



#### new 一个对象的执行顺序

>
> 1.静态资源（包括静态属性，静态方法，静态代码块）：父类静态执行完所有静态资源再执行子类静态；
>     执行一个类时，按所有静态资源的上下顺序来；（第一次new对象时就会检查这个类是否加载了，
>     如果没有，就进行类加载，类加载的同时，静态资源也会同时加载；
>     如果在new对象的时候类已经加载了，那么就不会再加载静态资源了，因为static只执行一次）
>
> 2.非静态资源（包括普通属性，构造器，匿名代码块（构造代码块））：父类执行完所有非静态资源然后再执行子类；（普通属性和匿名代码块在编译时会按上下顺序写在（每个）构造函数中的最前面，所以，）
>   会先按普通属性和匿名代码块的上下顺序执行，最后执行构造函数中的代码

堆是一种完全二叉树

构造函数可以被重载，析构函数不可以

#### 程序执行过程：

预编译、编译、汇编、链接

- 静态链接：在`编译`时，将库文件加入到 可执行程序
- 动态链接：在`运行`



#### 监听器  和 过滤器

> ​	监听器（listener）就是application、session、request三个对象创建、销毁或者往其中添加修改删除属性时`自动执行`代码的功能组件
>
> ​	过滤器：**对用户请求进行统一认证、对用户的访问请求进行记录和审核、对用户发送的数据进行过滤或替换、转换图象格式、对响应内容进行压缩以减少传输量、对请求或响应进行加解密处理**

#### 函数式编程

把运算过程尽量写成一系列嵌套的函数调用。

特点：

- 函数是"第一等公民"。函数与其他数据类型一样
- 只用"表达式"，不用"语句"。每一步都是单纯的运算，而且都有返回值。减少IO
- 没有"副作用"。不得修改外部变量的值。
- 不修改状态。
- 引用透明

优点：

- 代码简洁，开发快速
- 接近自然语言，易于理解
- 易于"并发编程"

##### 函数式接口

也是 java interface 的一种，典型例子：Comparator接口

> 满足这些条件 的interface
>
> 1. 只有1个抽象方法(SAM，single abstract method)
> 2. 可以有默认方法和静态方法
> 3. 可以用@FunctionalInterface 注解进行修饰

优点：使用极简的lambda表达式实例化接口

##### Lambda表达式

```java
Runnable task = () -> System.out.println("i am coming...");

```

参数类型可以省略、

lambda表达式同匿名内部类一样，访问外部变量有一个非常重要的限制：变量不可变（只是引用不可变，而不是真正的不可变）

> lambda表达式与匿名类的异同集中体现在三点上：
>
> - lambda就是为了优化匿名内部类而生，lambda要比匿名类`简洁`的多得多；
> - lambda`仅`适用于函数式接口，匿名类不受限；
> - 在匿名类内部，this关键字指向该抽象类实例，而lambda内部this指向闭包实例。如果需要在内部通过this关键字访问实例，必须使用匿名类；

# :baby_chick:  基础

#### 8大基本数据类型：

byte（1个）、boolean（1）、char（Unicode 2个字节）、short(2)、int(4)、float(4)、long(8)、double(8)    还有一个 void

int a 等无初始值必须初始化！(静态变量有初始值) 但数组有初始值  int[]:0   boolean[]:false

##### 浮点数累加误差

 浮点数由： 符号位 + 指数位 + 尾数部分，float 有效位：6-7位   double有效位 15-16位

原因：対阶时截掉尾数

不要让特别大数+小数

大数 是对象       `数组是对象` 是引用数据类型

- （对象）成员方法又称为实例方法

- 静态方法又称为类方法

#### final

当final变量是基本数据类型以及String类型时，如果在编译期间能知道它的确切值，则编译器会把它当做编译期常量使用

禁止重排序，保证可见性

#### String

在String中，一个英文字符占1个字节，而中文字符根据编码的不同所占字节数也不同。在UTF-8编码下，一个中文字符占3个字节；而使用GBK编码时一个中文字符占2个字节

String类型初始化后为 空字符串 ""  还有null串

final String ：String类不可继承    final char value[]: 数组不可变

字符串可以和任意类型拼接（转换成字符串 类型） str = str+100  底层实现：new StringBuilder().append(str).append(100).toString();

>  字面量  ：在常量池中找，若常量池没有，则先创建  （字面量是共享的）
>
>  其他：先在常量池中找，若常量池没有，则先创建，然后再在堆中创建，返回引用
>
>  String a = "abc" ：   创建1个对象  ，去常量池查找
>
>  String b = new String("abc") ：创建2个对象,"123"，还有一个堆对象
>
>  String c=“123”+“456”;创建 1个对象 ， 编译器优化后  自动拼接
>
>  String d=a+"456" : 创建3个对象，“456”，StringBuilder对象(a), "abc456"
>
>  String e=“123”+new String(“456”); ：创建了4个对象 ， "123","456",new Sting("456") ,堆对象"123456"
>
>  intern：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回 常量池中这个字符串的String对象；否则，将此String对象包含的字符添加到常量池中，并返回此String对象的引用。

##### StringBuilder

父类：AbstractStringBuilder    拼接效率高

##### StringBuffer

父类：AbstractStringBuilder    加锁

public `synchronized` StringBuffer append(String str)  

#### 异常

- 非受检查异常：运行时异常    不处理也能编译
- 受检查异常：IO异常

##### throws，throw

throws用在函数（声明异常） throw用在函数内（抛出具体的问题对象）

##### trt catch fianlly：

 try或catch有return：

先保存return的值，跳到finally执行完成之后再return ，如果finally也有return的话，会自动忽略try的return，执行finally

finally在绝大所数情况会执行，有4种情况会不执行：

- 在进入try之前就出异常
- try块中强制退出System.exit(0);
- 线程死亡

#### 自动装箱和拆箱

- 装箱：将基本类型⽤它们对应的引⽤类型包装起来； Integer的valueOf(int)
- 拆箱：将包装类型转换为基本数据类型；   Integer.intvalue(Integer)

> 数据缓存：
>
> 数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象,doubel和float没有缓存



#### 修饰符 访问权限

![](复习笔记.assets/1477033-20180916162539315-1554950059.png)

`慎用protected，容易破坏封装性。`



#### 重载 、重写

重写：运行时多态  继承、        异常不能更广、修饰符范围不能更小

重载：编译时就要确定走哪个 方法 ， 方法名一样但 `参数类型、个数、顺序不同`，返回值和修饰符范围无所谓。返回值不属于方法签名，

#### 抽象类和接口

接口：     是对一种行为的规范           

 方法类型  public, abstract,    default,static （   *JDK 1.8 以后，接口里可以有静态方法和默认方法。*（但必须有方法体实现））方法默认是 public abstract 类型的

数据默认都是 静态 （public  static/final）的  不能有私有方法和 私有变量

​     一个类可实现多个接口 

抽象类：可以有私有方法或私有变量

#### 面向对象 设计原则

SOLID:

- 单一职责  SRP
- 开放封闭  OCP
- 里式替换 LSP
- 接口隔离 ISP
- 依赖倒置 DIP

#### 代理

- 静态代理：程序员 自己 编写好 代理类
- 动态代理： 在 运行时 通过从反射 

### IO

#### 序列化与反序列化

序列化就是将一个对象转换成字节序列，方便存储和传输。

- 序列化：ObjectOutputStream.writeObject()
- 反序列化：ObjectInputStream.readObject()

不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。

实现Serializable 接口

使用`transient`  可以使一些 属性不被序列化



### 反射：

最基本的作用是程序在运行期间能够`获取类的所有信息（如字段信息、方法、属性、构造器等）`，可以通过反射获取类的构造方法来`实例化对象`，然后`动态代理`用到了反射。     

invoke():   method.invoke(object,parameter)

获取类的方法：

- Class.forName(fullClassPath) // 最安全、性能也是最好的方法
-  Hero.class  //之后 获取构造方法并创建对象 
-  new Hero().getClass()

无论什么途径获取类对象，都会导致静态属性被初始化，而且只会执行一次。（除了直接使用 Class c = Hero.class 这种方式，这种方式不会导致静态属性被初始化）

可以把类的配置文件（类全名）保存在文本文件，使用时读取、

```java
        Class cls = Class.forName("reflect.Foo");
        Method outMethod = cls.getDeclaredMethod("outInfo");
        // cls.newInstance(); 生成的是无参构造函数
        Constructor constructor = cls.getDeclaredConstructor(String.class);
        Object obj = constructor.newInstance("123");
        outMethod.invoke(obj);
```



### 注解：

应用在类、方法、参数、属性、构造器上的特殊修饰符

​         本质就是一个继承了 `Annotation` 接口的接口 

​         `底层原理：反射`   解析注解中的信息

​         元注解：修饰注解的注解，一般指定某个注解的生命周期以及作用目标等信息。

- @Target：注解的作用`目标`（方法、类（接口）、字段属性）。
- @Retention：注解的生命周期 。 
  - RetentionPolicy.SOURCE： Java源文件上的注解
  - RetentionPolicy.CLASS： Class类文件上的注解
  - RetentionPolicy.RUNTIME： 运行时的注解 
- @Documented：注解是否应当被包含在 JavaDoc 文档中
- @Inherited：是否允许子类继承该注解
- @Repeatable ：jdk1.8 新增  注解可重复

内置三大注解：

- @Override   重写父类方法
- @Deprecated    方法已经过期、不推荐使用
- @SuppressWarnings   压制警告

@FunctionalInterface ：jdk1.8 新增，约定函数式接口：如果接口中只有一个抽象方法（可以包含多个默认方法或多个static方法），配合Lambda 表达式 来使用。

可以自定义注解：

```java
//创建一个注解
public @interface XXConfig

//例子
@Target({METHOD,TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface JDBCConfig {
     String ip();
     int port() default 3306;
     String database();
     String encoding();
     String loginName();
     String password();
}
//使用
import anno.JDBCConfig;
@JDBCConfig(ip = "127.0.0.1", database = "test", encoding = "UTF-8", loginName = "root", password = "admin")
public class DBUtil {
    static {
        try {
            Class.forName("com.mysql.jdbc.Driver");
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
 
 public static Connection getConnection() throws SQLException, NoSuchMethodException, SecurityException {
        JDBCConfig config = DBUtil.class.getAnnotation(JDBCConfig.class);
        String ip = config.ip();
        int port = config.port();
        String database = config.database();
        String encoding = config.encoding();
        String loginName = config.loginName();
        String password = config.password();
 
        String url = String.format("jdbc:mysql://%s:%d/%s?characterEncoding=%s", ip, port, database, encoding);
        return DriverManager.getConnection(url, loginName, password);
    }
     
    public static void main(String[] args) throws NoSuchMethodException, SecurityException, SQLException {
        Connection c = getConnection();
        System.out.println(c);
    }
}
```



### 泛型

实现原理：

`类型擦除`：泛型基本上都是在`编译器`这个层次来实现的。在生成的Java字节码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会在编译器在编译的时候去掉。



## 架构

 流处理：实时、无边界  ：Hadoop

批处理：静态数据、有界  Storm

混合框架：Apache Spark、Apache Flink



# 集合

## 概述

![1](复习笔记.assets/1.gif)



**Collection** 接口的接口 对象的集合（单列集合） 
 ├——-**List** 接口：元素有序，可重复    可以存放多个null值
 │—————-├ **LinkedList** 接口实现类， 链表， 插入删除， 没有同步， 线程不安全   
 │—————-├ **ArrayList** 接口实现类， 数组， 随机访问， 没有同步， 线程不安全   
 │—————-└ **Vector** 接口实现类 数组， 同步， 线程安全 
 │ ———————-└ **Stack** 是Vector类的实现类  不推荐使用
 └——-**Set** 接口： 无序，不可重复。
 ├—————-└**HashSet** 使用hash表（数组）存储元素 
 │————————└ **LinkedHashSet** 链表维护元素的插入次序 
 └ —————-**TreeSet** 底层实现为二叉树，元素排好序

**Map** 接口 键值对的集合 （双列集合） 
 ├———**Hashtable** 接口实现类， 同步， 线程安全  不可以有null
 ├———**HashMap** 接口实现类 ，没有同步， 线程不安全   可存放一个key=null
 │—————–├ **LinkedHashMap** 双向链表和哈希表实现 
 │—————–└ **WeakHashMap** 
 ├ ——–**TreeMap** 红黑树对所有的key进行排序   不可以有null
 └———**IdentifyHashMap**

## ArrayList：

默认空，初始化容量（capacity）为10 ，每次扩大1.5倍（长度右移一位加上原来的长度）  容量`自动增长`

每插入一个元素，size++，按index插入会验证index是否小于size

不是同步的，ArrayList的iterator和listIterator方法返回的迭代器是**fail-fast**的 

可以使用1.`Collections.synchronizedList(new ArrayList(...));`保证线程安全。2.CopyOnWriteArrayList

MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 2^31 -8 (for storing size )（一些虚拟机需要用来存储头部信息 限制）

<img src="复习笔记.assets/20190503201340525.png" alt="1" style="zoom: 67%;" />

![image-20210414084405581](复习笔记.assets/image-20210414084405581.png)



## LinkedList：

线程不安全  底层：双向链表   首部插入效率高

可以使用`Collections.synchronizedList(new LinkedList(...));`保证线程安全。

- vector：老版本，线程安全、初始化 10 ，每次扩大2倍，申请必须是`连续内存`，只能在尾部进行插入和删除操作，效率低

## 队列

 Queue   先进先出  offer、poll 

### 双端队列

Deque 是Queue的子类

- ArrayDeque  ：基于数组
- LinkedList





- HashMap：初始化 16，扩大2倍   最大容量： 2^30 、负载因子为 0.75  内部静态类 Node（单向链表，它实现了Map.Entry接口  有key、value、hash、next属性） key、value值均可为null

- HashTable：初始化11，每次成原来2n+1，key、value值均不可为null

  

## HashMap：

结构：Node数组、链表、红黑树

长度：比传入容量参数值大的最小的2的n次方

扰动函数 hash：return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);    `高16位`  优化散列效果 ，hashCode范围太大。

允许key,value=null  放在table[0]

**若两个对象逻辑相等，那么他们的hashCode一定相等，反之却不一定成立。**

扩容是2的倍数：

    数组大小永远是2的幂次方，可以使用 位运算 代替 模运算，提高效率
       1. 降低碰撞概率，散列均匀， 计算bucket下标：hash&（n-1）  等同于使用表长度对hash取模；更好地散列值
       2. n-1 二进制最后一位是1 与h 与 后最后一位可能是1 or 0，不会浪费空间


fail-fast策略：快速失效策略。 尽早发现问题   modCount修改次数 iterator遍历

1.8 ：

 (求hash更高效 ）链表会转成红黑树   尾插法

扩容场景：

1. 哈希table为null 或长度为0；
2. Map中存储的k-v对数量超过了阈值`threshold`；
3. 链表中的长度超过了`TREEIFY_THRESHOLD`，但表长度却小于`MIN_TREEIFY_CAPACITY`(64)。

e.hash & oldCap  ==0 来决定 是否迁移到新的链表（0不移，1移）    newTab[j+oldCap]=hiHead;

https://juejin.cn/post/6844904013909983245#heading-27

线程不安全问题： `transfer()`时

1. 数据覆盖问题   头插法  1.7、1.8都有  

2. 扩容时导致死循环    只1.7有

   1.7：resize()时使用了头插法，将原本的顺序做了反转，并发时 再次操作形成环形链表

   1.8：resize()方式已经做了调整，使用两队链表，且都是使用的尾插法，多线程下，也顶多是从头结点再做一次尾插法，不会造成死循环。

3. 数据丢失 1.8 尾插法 可能多次插入到尾节点，未更新




多线程环境下保证 HashMap 的线程安全性，主要有如下几种方法：

- 使用 java.util.Hashtable 类，此类是线程安全的使用，效率低，不推荐 

- java.util.concurrent.ConcurrentHashMap，此类是线程安全的。效率高

- 使用 java.util.Collections.synchronizedMap () 方法包装 HashMap object，得到线程安全的 Map，并在此 Map 上进行操作。还可以用于其他collection类



put流程：

> 1. 哈希值值扰动，计算新的哈希
> 2. 判断tab是否为 空或者长度为0，如果是则进⾏扩容操作。  
> 3. 根据哈希值计算下标，如果对应⼩标正好没有存放数据，则直接插入即可否则需要覆盖。 tab[i =
>    (n - 1) & hash])    
> 4. 判断tab[i]是否为树节点，否则向链表中插⼊入数据，是则向树中插⼊入节点。
> 5. 如果链表中插⼊入节点的时候，链表⻓长度⼤大于等于8，则需要把链表转换为红⿊树。 treeifyBin(tab, hash);
> 6. 最后所有元素处理理完成后，判断是否超过阈值； threshold ，超过则扩容。  

查找流程：

> 1. 扰动函数，计算哈希
> 2. 判断tab是否位空或者长度为0，为空 return null
> 3. 计算数组下标   tab[i =(n - 1) & hash])    
> 4. 头结点是否是所要查找的点
> 5. 是否为 树节点 ； 若是则调用红黑树查找算法 不是则在链表中遍历查找Set

### 遍历方式

1、使用迭代器（Iterator）EntrySet的方式；

2、使用迭代器（Iterator）KeySet的方式；   map.keySet().Iterator().next() : 第一个key

3、使用foreach EntrySet的方式；

4、使用foreach KeySet的方式；

5、使用lambda表达式的方式；

6、使用StreamsAPI单线程的方式；

7、使用StreamsAPI多线程的方式

**Lambda 和 Stream** 更简洁和优雅， `iterator.remove()` **方法来进行删除**最安全



- treemap： 也是非线程安全的

## Set

- HashSet： 是 Set 接⼝的主要实现类 ， HashSet 的底层是 HashMap ，线程不安全的，可以存
  储 null 值；  

- LinkedHashSet ：是 HashSet 的⼦类，能够按照添加的顺序遍历； 

- TreeSet： 底层使⽤红⿊树，能够按照添加元素的顺序进⾏遍历，排序的⽅式有⾃然排序和定制排
  序  ，非线程安全

  保证唯一：compareTo()方法返回0.
  保证有序：自然排序和比较器排序   (若元素本身具有自然顺序特性（如Integer，String），则进行自然排序，否则要传入一个比较器对象)
   1.自然排序，是让集合中添加的元素对象实现Comparable接口，并重写该接口中comareTo方法根据返回值，来进行排序
  2.比较器排序，是在TreeSet构造中传入一个对象实现Comparator接口，重写compare方法，自定义比较顺序



## 树

- AVL树：（高度差不超过1）适合用于插入删除次数比较少，但查找多的情况   o（logn）

- BST： 二叉查找树

- 红黑树: 平衡二叉树的变体，`高度差可能>1`（弱平衡  所以相同节点的情况下，高度高于AVL树  所以`旋转次数变少`  整体性能优于AVL树）（通过对任何一条从根到叶子的路径上各个节点着色的方式的限制,红黑树确保`没有一条路径会比其它路径长出两倍`）  适合搜索,插入,删除操作多的情况  

  旋转变色：祖宗根节点必黑，允许黑连黑，不允许红连红；新增红色，爸叔通红就变色，爸红叔黑就旋转，爸红没叔也要旋，那黑往那旋

  > 红黑树的特性如下：
  >
  > - 每个节点要么是黑色，要么是红色
  > - 根节点必须为黑色
  > - 红色节点不能连续，即红色节点的孩子和父亲只能是黑色
  > - 任何节点到树的末端的任何路径包含的黑色节点个数相同
  >
  >  每次对红黑树操作后都要使其满足上述条件，调整红黑树的策略主要是：
  >
  > - 改变节点颜色；
  > - 改变树的结构（左旋操作、右旋操作）
  >
  > 根据红黑树的特点，TreeMap的containsKey(),get(),put(),remove()的时间复杂度都为log(n)。

- B+树：高度小（一般2-4层），多路，IO性能高

  

- hashcode：获取哈希码（在散列表中使用   判断索引位置  key值是否相等的先行判断）    为了提高效率，减少比较次数   使用31作为乘数 散列效果好  且不会造成溢出

- equals： 默认：判断两个对象的地址是否相等，要重写 hashCode函数才好用



# :desktop_computer: OS

## 基本名词

- 并发： 宏观上同时运行多个程序 
- 并行：同一时刻能运行多个指令。需要硬件支持
- PCB：进程控制块，系统中存放、管理和控制进程信息的数据结构
- TCB：线程控制块
- FCB：文件控制块
- PSW：`程序状态字寄存器`，用于存放PC、IR等的信息
- 活锁:  两个进程 相互让 资源

## 进程、线程、协程

|                           | 进程                                                         | 线程                                                         | 协程                                                         |
| ------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义                      | `资源分配`和拥有的基本单位                                   | `任务调度和执行的最小单位`                                   | 用户态的轻量级线程，线程内部调度的基本单位                   |
| 切换情况                  | 进程CPU环境(栈、寄存器、`页表和文件句柄等`)的保存以及新调度的进程CPU环境的设置<br>涉及`虚拟地址空间的切换`,所以费时 | `保存和设置程序计数器、少量寄存器和栈的内容`                 | 先将寄存器上下文和栈保存，等切换回来的时候再进行恢复         |
| 切换者                    | 操作系统                                                     | 操作系统                                                     | 用户                                                         |
| 切换过程                  | 用户态->内核态->用户态                                       | 用户态->内核态->用户态                                       | `用户态(没有陷入内核)`                                       |
| 调用栈                    | 内核栈                                                       | 内核栈                                                       | `用户栈`                                                     |
| 拥有资源                  | CPU资源、内存资源、文件资源和句柄等                          | 程序计数器、寄存器、`栈`和状态字<br> `共享堆、全局变量、静态变量、指针，引用、文件等` | `拥有自己的寄存器上下文和栈`                                 |
| 并发性                    | 不同进程之间切换实现并发，各自占有CPU实现并行                | `一个进程内部的多个线程并发执行`                             | `同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理` |
| 系统开销                  | 切换`虚拟地址空间、内核栈和硬件上下文，CPU高速缓存失效、页表切换`，开销很大 | 切换时只需保存和设置少量`寄存器内容`，因此开`销很小`         | 直接操作栈则`基本没有内核切换的开销`，可以不加锁的访问全局变量，所以`上下文的切换非常快` |
| 通信方面                  | 进程间通信需要借助`操作系统`                                 | 线程间可以直接读写进程数据段(如全局变量)来进行通信           | 共享内存、消息队列                                           |
| Windows下<br>可用虚拟空间 | 2G                                                           | 1M                                                           |                                                              |
| 结构                      | 代码段 + 堆栈段 + 数据段<br> 划分进程为`进程控制块、正文段、数据段`可以实现`共享正文，共享数据和可重入` |                                                              |                                                              |



一个进程至少包含一个主线程，也可以有更多的子线程。一个线程也可以有多个协程

线程的状态转换：JVM需要通过操作系统内核中的`TCB`（Thread Control Block）模块来改变线程的状态

协程的暂停完全由程序控制（完全在用户态），开销小  Java没有原生支持，但有框架。主要是Python（async/await）、Go语言



操作系统四大特性： `共享` 、`异步` 、`虚拟`、 `并发`

进程的特性：`动态`、`并发`、独立、异步

```c++
struct task_struct {
    // 进程状态
    long              state;
    // 虚拟内存 结构体：载入可资源和可执行文件
    struct mm_struct  *mm;
    // 进程号
    pid_t             pid;
    // 指向父进程的指针
    struct task_struct   *parent;
    // 子进程列表
    struct list_head      children;
    // 存放文件系统信息的指针
    struct fs_struct      *fs;
    // 一个数组，包含该进程打开的文件指针
    struct files_struct   *files;
};
```

**文件描述符」就是指这个文件指针数组的索引**，默认情况下 0 是输入，1 是输出，2 是错误。

一切被抽象成文件（设备也是）

![1](https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdEZbbic0diawibWHE9EoMFmX8qBRhdjExXRmiccwQ37ZXZ4645LlAdYY4VOUUibUDNrLjNLUGXWjGPibOgw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

对Linux来说：线程的某些数据区域和其父进程是共享的，而子进程是拷贝副本，而不是共享

`线程之间共享进程打开的文件标识符、堆区（但自身维护堆栈）、进程的公共变量`

#### 孤儿、僵尸进程

- 孤儿进程：父进程结束了，而它的一个或多个子进程还在运行。子进程的资源由`init进程`(进程号PID = 1)回收。

- 僵尸进程: 子进程比父进程先结束，等父进程捕获。还会保存剩余`进程id` 、`进程退出的状态`和`占用cpu的时间`。无法使用kill直接杀死。

  解决：1.通过signal(SIGCHLD, SIG_IGN)通知内核对子进程的结束不关心，由内核回收。
               2.父进程调用wait/waitpid等函数等待子进程结束。

### 进程状态

![](复习笔记.assets/QQ截图20210226220417.png)

- 就绪状态（ready）：`等待被调度`（获取时间片）
- 运行状态（running）
- 阻塞状态（waiting）：`等待资源`

应该注意以下内容：

- `只有就绪态和运行态可以相互转换，其它的都是单向转换`。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
- 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。

#### 进程终止方式

1、main函数的自然返回，`return` 
2、调用`exit`函数，属于c的函数库
3、调用`_exit`函数，属于系统调用
4、调用`abort`函数，异常程序终止，同时发送SIGABRT信号给调用进程。 
5、接受能导致进程终止的信号：ctrl+c (^C)、SIGINT(SIGINT中断进程) 

**exit和_exit的区别**    exit封装了

![](复习笔记.assets/1568016798542.png)

### 线程状态

![线程状态转换](复习笔记.assets/7e76cc17-0ad5-3ff3-954e-1f83463519d1.jpg)

### 通信方式：

通信是手段

**进程通信**

管道(匿名、命名)，消息队列，共享内存，信号，信号量，socket套接字(可用于不同机器间)

**线程通信**

信号、信号量、锁（互斥锁、读写锁和自旋锁）、条件变量

### 同步方式：

控制多个进程按一定顺序执行；是目的

**进程**

临界区、同步与互斥、信号量、管程



## 用户态和核心态

- **用户态：**只能受限的访问内存，运行所有的应用程序

- **核心态：**运行操作系统程序，cpu可以访问内存的所有数据，包括外围设备

中断类型：  1.系统调用  2.异常    3.外围设备的中断。

### CPU上下文：

CPU寄存器、PC

上下文切换：保存前一个CPU的上下文，加载新任务的上下文到寄存器和PC、PC跳转到新位置，开始执行新任务

一次系统调用 会发生两次 CPU上下文切换，用户态 -> 内核态  系统调用 -> 用户态。  不涉及进程切换，一直在同一个进程中。

#### 分类

- 进程上下文切换： 进程是由 内核管理 和调度的， 切换只能发生在 内核态

  场景： 时间片耗尽、系统资源不足、sleep、优先级更高的进程、硬中断

- 线程 上下文切换：

- 中断 上下文 切换：为了快速响应硬件，`中断会打断进程调度`。`优先级 比进程 更高` 。但只发生 在 内核态，即使打断了进程，只需要保存内核态中断服务程序所必须的状态就行



## 进程调度

`操作系统调度`层次分为三类：高级调度、中级调度、低级调度。

<font color= "orange">高级调度</font>：从`外存`的后备作业中挑选一个(多个)，建立相应的PCB，获得竞争处理的权力。

后面会讲到的虚拟内存技术出现后，为了提高系统的利用率和吞吐量，会将暂时等待的进程挂起到外存。

<font color= "orange">中级调度</font>：能够决定哪个被挂起的进程重新回到`内存`中。

<font color= "orange">低级调度</font>:从就绪队列中选取一个进程，使其能够被`CPU`处理。

三种调度方式的频率从低到高。

### 调度算法

- 先来先服务    非抢占
- 短作业优先      非抢占
- 最短剩余时间优先
- 优先级调度
- 时间片轮转
- 多级反馈队列

## 死锁

### 条件

- 互斥
- 请求并保持
- 非剥夺
- 循环等待

### 解决方法

- 死锁预防：破坏死锁的任意一条件
  - `资源一次性分配`，从而剥夺请求和保持条件
  - 可剥夺资源：`即当进程新的资源未得到满足时，释放已占有的资源`，从而破坏不可剥夺的条件
  - 资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件

- 死锁避免

  > 银行家算法：进程提出资源申请时，先判断这次分配会不会导致系统进入不安全状态，如果会则不答应请求，让该进程阻塞。简而言之，请求不能大于手中的资源。这种算法也叫银行家算法。

- 死锁检测与恢复

  资源分配图算法

  **死锁恢复：**资源剥夺将死锁的进程挂起，释放资源；撤销进程，直接将部分或者全部死锁进程撤销；进程回退，让进程回退的足以避免死锁的地方。

- 死锁忽略

  顾名思义，忽略这个死锁，死锁概率本不高，就算出现了也只是局部的死锁，直接不管反而能提高资源利用率与整体运行的速度，也有个好听的名字叫鸵鸟算法，这样性能会提升不少，大部分操作系统也采用死锁忽略的策略。

## IO

> 文件描述符：`是一个用于表述指向文件的引用的抽象化概念`。是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表
>
> 3个标准文件描述符：`0<` 是标准输入（`stdin`）、`1>` 是标准输出（`stdout`），`2>` 是标准错误输出（`stderr`）。



### 同步与异步：

-  同步：调用方需`要等待结果的返回`。但是一旦调用返回，就得到返回值了

- 异步：调用者`不需要立刻得到返回消息`（结果）。`实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者`。

### 阻塞与非阻塞：

`是程序（线程）等待消息通知时的状态角度来说的`

- 阻塞：调用是指调用结果返回之前，当前线程会被`挂起`，一直处于等待消息通知，`不能`够执行其他业务。
- 非阻塞：结果返回前，线程可做其他事，不被挂起

> 对于同步调用来说，很多时候当前线程可能还是激活的，只是从逻辑上当前函数没有返回而已，此时，这个线程`可能`也会处理其他的消息
>
> 所以同步（异步）也都分为 阻塞与非阻塞
>
> `异步操作是可以被阻塞住的，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞。`

### 5种I/O模型

一个输入操作通常包括两个阶段：

- 等待数据准备好
- 从内核向进程复制数据

对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。

- 阻塞IO（BIO）
- 非阻塞IO（NIO）   是  块， 轮询
- IO复用（select/poll/epoll   事件驱动IO）
- 信号驱动IO   （SIGIO）
- 异步IO（asynchronous I/O  AIO）

![](复习笔记.assets/1492928105791_3.png)

- 同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。
- 异步 I/O：第二阶段应用进程不会阻塞。



### select、poll、epoll

定义：内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程

`一个进程可以监视多个描述符`，`一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作`

优点：系统开销小，系统不必创建进程/线程

- select： 本质上是通过`设置或者检查存放fd标志位的数据结构`来进行下一步处理    从用户态copy到内核态，返回就绪的文件描述符

  缺点：1.`单个进程能够监视的文件描述符的数量存在最大限制`，在Linux上一般为1024
             2. **轮询的方法，效率较低**
             3. `需要维护一个用来存放大量fd的数据结构`

- poll :查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没  有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。 使用`链表`存储（**没有最大连接数的限制**）

  缺点：1.`大量的fd的数组被整体复制`于用户态和内核地址空间之间，而不管这样的复制是不是有意义。

  ​            2.poll还有一个特点是“`水平触发`”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。

  >    select和poll都需要在返回后，`通过遍历文件描述符来获取已经就绪的socket`。事实上，`同时连接的大量客户端在一时刻可能只有很少的处于就绪状态`，因此随着监视的描述符数量的增长，其效率也会线性下降。

 - epoll：使用一个`文件描述符管理多个描述符`，将用户关系的文件描述符的事件存放到`内核`的一个`事件表`中，这样在用户空间和内核空间的copy只需一次。`支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次`。还有一个特点是，`epoll使用“事件”的就绪通知方式`，通过epoll_ctl注册fd，`一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd`，epoll_wait便可以收到通知

   优点：1.没有最大并发连接的限制

   ​            2.效率提升，不是轮询的方式，不会随着FD数目的增加效率下降`。只有活跃可用的FD才会调用callback函		 数；`即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关

   ​             3.内存拷贝  

   文件描述符`操作模式`：

   ​      LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，`应用程序可以不立即处理该事件`。下次调用epoll_wait时，`会再次响应应用程序并通知此事件`。

   ​     ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，`应用程序必须立即处理该事件`。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。

   > 默认是水平触发：只要有数据，epoll_wait函数就一直返回
   >
   > 边缘触发：只有socket状态发生变化，epoll_wait函数才会返回。   数据的`完整性`（不能及时取出）

## 内存管理

### 虚拟技术

两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。

多进程与多线程：多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。

`虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。` 进程执行时不需要全部载入内存，可以部分载入到内存中

### 编码方式

- 按字节编码：每个存储单元大小为 一字节，8位
- 按字编码：每个存储单元大小为 二字节，16位

![](复习笔记.assets/format,f_auto.png)

大端：**低地址存放高位**  跟字符串顺序 一样

小端： **低地址存放低位**  地址的增长顺序与值的增长顺序相同

- 分页    大小固定，信息的物理单位
- 分段     信息的逻辑单位  可以动态增长  有外碎片 需要紧凑技术消除
- 段页式

### 页置换算法

- 先进先出FIFO    ： 如果页面已存在 ，则无操作
- 最近最久未使用LRU：如果页面已存在，将已存在划掉重新加入
- 最近未使用
- 二次机会
- 时钟
- 最佳置换算法OPT（理论上的）

### 连续分配管理方式

- 单一连续 
- 固定分区   有内碎片 需要 内存交换 解决
- 动态分区

####  动态分区分配算法

- 首次适应   每次从最低开始查找
- 最佳适应
- 最坏适应
- 邻近适应算法    从链头 开始查找

| 算法     | 算法思想                                           | 分区排列顺序                                 | 优点                                                         | 缺点                                                         |
| -------- | -------------------------------------------------- | -------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 首次适应 | 从头到尾找适合的分区                               | 空闲分区以地址递`增`次序排列                 | 综合看性能最好。**算法开销小**，回收分区后一.般不需要对空闲分区队列重新排序 |                                                              |
| 最佳适应 | 优先使用`更小`的分区，以保留更多大分区             | 空闲分区以容量递`增`次序排列                 | 会有更多的大分区被保留下来，更能满足大进程需求               | 会产生很多太小的、难以利用的碎片;**算法开销大**，回收分区后可能需要对空闲分区队列重新排序 |
| 最坏适应 | 优先使用更大的分区，以防止产生太小的不可用的碎片   | 空闲分区以容量递`减`次序排列                 | 可以减少难以利用的小碎片                                     | 大分区容易被用完，不利于大进程;**算法开销大**(原因同上)      |
| 邻近适应 | 由首次适应演变而来，每次从上次查找结束位置开始查找 | 空闲分区以地址递增次序排列(可排列成循环链表) | 不用每次都从低地址的小分区开始检索。**算法开销小**(原因同首次适应算法) | 会使高地址的大分区也被用完                                   |

### 快表

快表，又称联想寄存器(TLB) ，是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。

![](https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.2/202102/QQ截图20210226212752.png)

****



## 程序运行过程

1. 预编译

   删除注释、处理预编译指令

2. 编译

   词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。

3. 汇编

   将汇编代码转变成机器可以执行的指令(机器码文件)

4. 链接

   - 静态链接
   - 动态链接  ： 在程序运行时才 拼接



## 异常和中断

**相同点**

- 最后都是由CPU发送给内核，由内核去处理

- 处理程序的流程设计上是相似的

**不同点**

- 产生源不相同，`异常是由CPU产生的，而中断是由硬件设备产生的`
- 内核需要根据是异常还是中断调用不同的处理程序
- `中断不是时钟同步的`，这意味着中断可能随时到来；异常由于是CPU产生的，所以它是时钟同步的
- 当处理中断时，处于中断上下文中；处理异常时，处于进程上下文中

## 内存泄漏

内存泄漏（Memory Leak）是指程序中已动态分配的`堆`内存由于某种原因程序`未释放或无法释放`，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。 `长生命周期的对象持有 短生命周期的对象`

例子：

- Handler  ：`非静态内部类`或者`匿名内部类`是依赖于外部类的，默认是持有外部类的引用的。导致不回收activity
  - 解决：使用 static修饰Handler。  使用弱引用的activity 访问变量

## 零拷贝

> 磁盘 I/O 是非常慢的，所以 Linux 内核通过减少磁盘 I/O 次数来减少I/O时间，在系统调用后，会把用户数据拷贝到内核中缓存起来，这个内核缓存空间也就是【页缓存：PageCache】，只有当缓存满足某些条件的时候，才发起磁盘 I/O 的请求。
>
> - 直接 I/O，不会发生内核缓存和用户程序之间数据复制，跳过操作系统的页缓存，`直接经过文件系统访问磁盘。`
> - 非直接 I/O，正相反，读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。
>
> 小文件：使用页缓存
> 大文件：异步IO+直接IO

**避免**CPU将数据从一块存储拷贝到另外一块存储，让数据传输不需要经过用户空间

- 使用mmap()代替read,  `将内核缓冲区 与应用程序(用户空间) 共享`  但容易 被`另一个进程截断`

![](复习笔记.assets/webp.webp)



- 使用sendfile ：利用`DMA`引擎将文件内容拷贝到内核缓冲区去，将带有文件位置和长度信息的缓冲区描述符添加socket缓冲区去。   不经过用户态，   需要硬件以及驱动程序支持的

  ![](复习笔记.assets/带DMA的sendfile.png)



- splice 管道缓冲区机制

## 写时复制 COW

线程共享数据，只有修改时，才拷贝到自己的应用空间

##  文件管理

### 文件格式

- 流式文件： 由字符序列组成，文件内信息不再划分结构

### 磁盘调度算法

- FCFS： 先来先服务
- SSTF:最短寻道时间
- 电梯调度： 扫描SCAN算法，与当前磁道距离最近且 是在当前扫描方向上的
- 循环扫描CSCAN算法 1

# :computer: 计网

## 名词解释

- RTO: 重传间隔。通常是上次的两倍，计量单位是RTT
- RTT: 数据报在一个网络中一个往返用时，大小不稳定
- 无状态：数据包的发送、传输和接收都是相互独立的
- 无连接：通信双方都不长久的维持对方的任何信息
- NAT：网络地址转换协议，将公网IP转为 私网IP
- DHCP：动态主机配置协议
- TTL： Time To Live，ICMP包的转发次数（跳数），避免IP包在网络中的无限循环和收发，节省了网络资源
- IPv4：32bits，分四组
- IPv6: 128bits，分为8组，没有分片，具有流，实时传输的服务。
  - 隧道： 转换
  - 双栈：同时启用IPv4协议和IPv6
- 广播：把pkt路由至所有节点  
- 组播：以“尽力而为”的形式发送信息到 某个 目标组
- 路由：pkt从发送方流向接收方,网络层决定pkt路径.计算路径的算法即路由选择算法。 通常由软件(算法)实现
- 转发： pkt到达router后,router为其选择合适的输出链路。发生在路由器上

## OSI

### 简要概括

- 物理层：底层数据传输，如网线；网卡标准。 

- 数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址。

- 网络层：定义IP编址，定义路由功能；如不同设备的数据转发。

- 传输层：端到端传输数据的基本功能；如 TCP、UDP。

- 会话层：控制应用程序之间`会话能力`（如session认证、断点续传）；如不同软件数据分发给不同软件。

- 表示层：数据格式标识，基本`压缩加密`功能。

- 应用层：各种应用软件，包括 Web 应用。

说明：

- 在四层，既传输层数据被称作**段**（Segments）；
- 三层网络层数据被称做**包**（Packages）；
- 二层数据链路层时数据被称为**帧**（Frames）；
- 一层物理层时数据被称为**比特流**（Bits）。

### 总结

- 网络七层模型是一个标准，而非实现。
- 网络四层模型是一个实现的应用模型。
- 网络四层模型由七层模型简化合并而来。

### 分层的好处

- 各层之间独立
- 灵活性好
- 结构上可分割开
- 易于实现和维护
- 促进标准化工作

## 常见应用层协议和运输层、网络层协议

- 应用层：HTTP(S)、SMTP（邮件传送协议，25号端口）、DNS(53)、FTP（21）、Telnet（23）、POP(接收邮件)、IMAP
- 传输层：TCP 、UDP
- 网络层：ICMP(Internet控制报文协议，   超文本传输安全协议、错误侦测与回报机制) 、IP、IGMP(Internet组管理协议)、ping（基于ICMP寻址 ，arp找mac地址）、路由器、防火墙、AS间：BGP(边界网关协议)、AS内：RIP(路由信息协议 基于DV算法)，OSPF算法(基于LS算法 可以分级)
- 数据链路层：网卡、网桥、交换机.   ARP(地址解析协议)，RARP（反向地址转换协议：mac-> ip）、PPP(点对点协议)
- 物理层：中继器、集线器

## TCP与UDP区别和应用场景

TCP（Transmission Control Protocol 传输控制协议）是一种`面向连接的、可靠的、基于字节流`的`传输层`通信协议。

| 类型 |             特点             |                     性能                      |    应用过场景    | 首部字节  | 备注                               |
| ---- | :--------------------------: | :-------------------------------------------: | :--------------: | :-------: | ---------------------------------- |
| TCP  |   面向连接、可靠、`字节流`   |            传输效率慢、所需资源多             |  文件、邮件传输  |  `20`-60  | 只能`点到点`                       |
| UDP  | 无连接、不可靠、数据`报文段` | 传输效率快、所需资源少（内容不能超过512字节） | 语音、视频、直播 | `8个`字节 | 支持一对一、一对多、多对一、多对多 |

​	**基于TCP的协议：**HTTP、FTP、SMTP

​	**基于UDP的协议：**RIP、DNS、SNMP

> RIP:  Routing Information Protocol，路由信息协议）是一种内部网关协议（IGP），是一种动态路由选择协议，用于自治系统（AS）内的路由信息的传递。

## DNS的工作原理？

- Windows查看dns缓存： ipconfig/displaydns
- 缓存 

将主机域名转换为ip地址，属于应用层协议，使用UDP传输。

![](https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.1/202103/QQ截图20210317172225.png)
过程：
总结： `浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。`
一、主机向本地域名服务器的查询一般都是采用`递归`查询。(帮忙查)
二、本地域名服务器向根域名服务器的查询的`迭代`查询。（只告诉相关服务器，还是自己去查）
1)当用户输入域名时，浏览器先检查自己的缓存中是否 这个域名映射的ip地址，有解析结束。
2）若没命中，则检查操作系统缓存（如Windows的hosts）中有没有解析过的结果，有解析结束。
3）若无命中，则请求本地域名服务器解析（ LDNS）。
4）若LDNS没有命中就直接跳到根域名服务器请求解析。根域名服务器返回给LDNS一个 主域名服务器地址。
5） 此时LDNS再发送请求给上一步返回的gTLD（ 通用顶级域）， 接受请求的gTLD查找并返回这个域名对应的Name Server的地址
6） Name Server根据映射关系表找到目标ip，返回给LDNS
7) LDNS缓存这个域名和对应的ip， 把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结束



## HTTP结构

1. `起始行`：用于区分是响应报文还是请求报文。在请求报文就是**请求行**，在响应报文就是**状态行**

   请求行 = 方法 + url + 版本                   

   响应行 = 版本 + 状态码 + 状态信息描述            

   方法：GET\POST\OPTIONS\HEAD\PUT\DELETE\TRACE

2. `首部行`（请求报头、响应报头）：说明浏览器、服务器、或者报文主题的一些信息。首部行有好几行，每行都有`换行和回车`

    请求消息头：Accept、Accept-Encoding、Accept-Language、Cache-Control、Host等

    响应消息头：Age、Cache-Control、Content-Encoding、Content-Length、Content-Type

   以`CR  LF(一行空格)`区分首部行 与数据体 （`空的文本行` 来终止报头列表)

3. `数据体`：包括请求携带的信息或者和服务器返回的HTML页面。

   

## HTTP请求

| 方法    | 描述                                                         |
| :------ | ------------------------------------------------------------ |
| GET     | 向特定资源发送请求，查询数据，并返回实体                     |
| POST    | 向指定资源提交数据进行处理请求，可能会导致新的资源建立、已有资源修改 |
| HEAD    | 类似GET请求，返回的响应中没有具体的内容，用于`获取报头`      |
| DELETE  | 请求服务器删除指定标识的资源                                 |
| OPTIONS | 可以用来向服务器发送请求来测试服务器的功能性，`查询支持的方法` |
| TRACE   | 回显服务器收到的请求，用于测试或诊断，`追踪路径`             |
| CONNECT | 使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络`隧道传输`。 |
| PUT     | 向服务器上传新的内容 、`文件`，不推荐使用                    |
| PATCH   | 对 PUT 方法的补充，用来对已知资源进行局部更新                |

###  get和Post区别：

|          | GET                                                          | POST                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 可见性   | 数据在URL中对所有人可见                                      | 数据不会显示在URL中                                          |
| 安全性   | 与post相比，get的安全性较差，因为所发送的数据是URL的一部分(以?分割，&相连) | 安全，因为参数不会被保存在浏览器历史或web服务器日志中        |
| 数据长度 | 受限制，最长2kb                                              | 无限制                                                       |
| 编码类型 | application/x-www-form-urlencoded  只能进行url编码           | multipart/form-data   支持多种编码方式                       |
| 缓存     | 能被缓存   可以被   bookmark                                 | 不能被缓存                                                   |
|          | 产生1个TCP包、回退无害                                       | 产生2个TCP包、回退会再次提交请求 （先发送header，再data）（属于部分浏览器或框架的请求方法，但不属于post必然行为） |
|          | 具有幂等性（多次请求结果一致）                               |                                                              |
|          | body体不带数据，会导致 缓存机制 失效                         |                                                              |



## 重定向和转发区别

​	**重定向：redirect：**

​			地址栏发生变化	

​			重定向可以访问其他站点（服务器）的资源

​			重定向是`两次请求`。不能使用request对象来共享数据

​	**转发：forward：**

​			转发地址栏`路径不变`

​			转发只能访问当前服务器下的资源

​			转发是一次请求，可以使用request对象共享数据

## 键入URL的之后过程

​	**过程：**DNS解析、TCP连接、发送HTTP请求、服务器处理请求并返回HTTP报文、关闭TCP连接、浏览器渲染、结束

1. 解析URL   生成HTTP消息

2. DNS解析 IP （浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存  本地 根域名服务器、顶级域名服务器、权威域名服务器）

   浏览器检查域名是否在缓存当中（要查看 Chrome 当中的缓存， 打开 chrome://net-internals/#dns）。

   如果缓存中没有，就去调用 `gethostbyname` 库函数（操作系统不同函数也不同）进行查询。

   gethostbyname` 函数在试图进行DNS解析之前首先检查域名是否在本地 Hosts 里，Hosts 的位置 [不同的操作系统有所不同](https://en.wikipedia.org/wiki/Hosts_(file)#Location_in_the_file_system)` 

   `如果 `gethostbyname` 没有这个域名的缓存记录，也没有在 `hosts` 里找到，它将会向 DNS 服务器发送一条 DNS 查询请求。DNS 服务器是由网络通信栈提供的，通常是本地路由器或者 ISP 的缓存 DNS 服务器

   如果在一个子网内采用ARP地址解析协议进行ARP查询如果不在一个子网那就需要对默认网关进行DNS查询，如果还找不到会一直向上找根DNS服务器，直到最终拿到IP地址（全球好像一共有13台根服务器）

3. HTTP传输工作交给OS中的协议栈：

   - 上半部分：TCP 和 UDP 协议：接受应用层的委托执行收发数据的操作。
   - 下半部分：IP协议：控制网络包收发操作； 
     - `ICMP`:用于告知网络包传送过程中产生的错误以及各种控制信息。
     - `ARP` :用于根据 IP 地址查询相应的以太网 MAC 地址

4. 可靠传输 TCP：生成tcp报文 进行数据包的编号、拆分、组装

5. 远程定位： IP   协议：06   TCP ；查路由表：目的ip与子网掩码相`与` 匹配

6. 两点传输：MAC

   - 发送方MAC：网卡生产时写入到 ROM
   - 接收方MAC：ARP协议 广播

7. 出口：网卡 ：数字信号转换为电信号  

   - 网卡驱动从 IP 模块获取到包之后，会将其**复制**到网卡内的缓存区中，接着会其**开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列（FCS）**。

8. 交换机：在MAC层，但本身不具有MAC地址；将数字信号转换为电子信号，通过包末FCS校验错误。

   通过MAC表查MAC地址，没有则广播

9. 路由器：FCS校验，检查MAC地址   `子网掩码 与 IP做 & 运算` 

### 路由器与交换机的区别：

- 路由器：**寻址，转发（依靠 IP 地址）**  内有路由表   基于IP设计，俗称俗称三层网络设备
- 交换机：**过滤，转发（依靠 MAC 地址）**  内有MAC表   基于以太网设计，俗称二层网络设备



## 状态码

1）状态码分类：
    1XX：信息型，服务器收到请求，需要请求者`继续`操作；
    2XX：成功型，请求成功收到，理解并处理；
    3XX：重定向，需要进一步的操作以完成请求；
    4XX：客户端错误，请求包含语法错误或无法完成请求；
    5XX：服务器错误，服务器在处理请求的过程中发生了错误；
2）常见状态码：
    200：客户端请求成功  OK；
    201:   已创建。服务器在请求的响应中建立了新文档;应在定位头信息中给出它的URL。
    301：资源(网页等)被`永久`转移到其它URL；
    302：`临时`重定向；
    303：同302，但`会要求使用get请求`
    304： `报文不满足请求条件`
    307：临时重定向，但`不会`要求把post请求变成 get请求
    400：是一种`错误请求`，客户端请求有`语法错误`，不能被服务器所理解；
    401：`未经授权`的一种请求，这个状态代码必须和WWW-Authenticate报头域一起使用；`需要用户验证` 
    403：`Forbideen` --- 服务器理解请求客户端的请求，但是拒绝执行此请求。
    404：`请求资源不存在`，可能是输入了错误的URL；
    405：请求方法不允许
    500：`服务器内部发生了不可预期的错误`；
    502：`Bad gateway`  内部网络故障
    503`：服务器暂时处于超负载或维护，当前不能处理客户端的请求，一段时间后可能恢复正常；（`限流`）
    504：Gateway Timeout



## HTTP各版本之间的区别

​	**HTTP1.0：**默认使用Connection: close，浏览器每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（`无连接`），服务器不跟踪每个客户端也不记录过去的请求（无状态）。

​	**HTTP1.1：**默认使用Connection: keep-alive（`长连接`），避免了连接建立和释放的开销；通过Content-Length字段来判断当前请求的数据是否已经全部接受。不允许同时存在两个并行的响应。`通过 Cache-Control 首部字段来控制缓存。`

​	**HTTP2.0：**`引入二进制数据帧和流的概念，其中帧对数据进行顺序标识`；因为有了序列，服务器可以`并行`的传输数据。多路复用

并发时：内存占用过多  可以使用心跳检测机制解决（默认2h  减少长连接时间）

​	**HTTP3.0：**基于UDP实现，QUIC协议，实现了类似TCP的流量控制、传输可靠性的功能。

​	**http1.0和http1.1的主要区别如下：**
​		1、缓存处理：1.1添加更多的缓存控制策略（如：Entity tag，If-Match）
​		2、网络连接的优化：1.1支持断点续传
​		3、错误状态码的增多：1.1新增了24个错误状态响应码，丰富的错误码更加明确各个状态
​		4、Host头处理：支持Host头域，不在以IP为请求方标志
​		5、长连接：减少了建立和关闭连接的消耗和延迟。

​	**http1.1和http2.0的主要区别：**
​		1、新的传输格式：2.0使用二进制格式，1.0依然使用基于文本格式
​		2、`多路复用`：连接共享，不同的request可以使用同一个连接传输（最后根据每个request上的id号组合成			  正常的请求）
​		3、header压缩：由于1.X中header带有大量的信息，并且得重复传输，2.0使用encoder来减少需要传输的			  hearder大小
​		4、服务端推送：同google的SPDUY（1.0的一种升级）一样

## HTTP与HTTPS之间的区别

​		

|              HTTP              |                   HTTPS                   |
| :----------------------------: | :---------------------------------------: |
|           默认端口80           |               默认端口`443`               |
| 明文传输、数据未加密、安全性差 | 传输过程ssl（安全套接字）加密、安全性较好 |
|     响应速度快、消耗资源少     | 响应速度较慢、消耗资源多、需要用到CA证书  |

### 		**HTTPS链接建立的过程：**

tcp三次握手 + 2次RTT     12个包（3+ 4*2 +1）

HTTPS 采用混合的加密机制，使用**非对称密钥加密用于传输对称密钥来保证传输过程的安全性**，之后使用**对称密钥加密进行通信来保证通信过程的效率**。

![](https://cdn.jsdelivr.net/gh/forthespada/mediaImage2@1.4/202103/net-73-1.png)

![img](复习笔记.assets/F6631517E1E7C927BCBA7583C70B4A04.jpg)

​			1.首先客户端先给服务器发送一个请求

​			2.服务器发送一个SSL证书给客户端，内容包括：证书的发布机构、有效期、所有者、签名以及公钥

​			3.客户端对发来的公钥进行真伪校验，校验为真则使用公钥对双方通信的对称秘钥进行加密，并发送给服务器端

​			4.服务器端使用私钥进行解密并使用对称密钥加密确认信息发送给客户端

​			5.随后客户端和服务端就使用对称密钥对数据进行加密解密，信息传输

公钥放在数字证书中。

#### 优化

![](复习笔记.assets/473210-20200506222815219-485612434.png)

计算密集型

- 硬件优化： 更快的CPU
- 软件优化：TLS使用高版本（1.3）、证书传输和验证优化、会话复用



（信息摘要算法：SHA2）

### 加密算法

- 可逆加密
  - 对称加密： DES、AES
  - 非对称加密：RSA
- 不可逆加密
  - md5

#### 		**对称加密算法：**

​			双方持有相同的密钥，且加密速度快，典型对称加密算法：`DES`、AES

​           加密和解密用同一个密钥，重点在`密钥的配送`

`Diffie-Hellman 密钥交换算法`：**通过一些共享的数字，双方「心中」各自「生成」了一个相同的秘密，而且双方的这   	个秘密，是第三方窃听者无法生成的**。

![1](https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdEnCxMxGb3LgzNf4aunA3go856rWoHD8VskOwTnLWl9Zap3VZdeRsa9Ztqrnjs17WDRk1sQq2fmrQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

但Hack可能冒充中间人  相互发送。所以需要使用`数字签名`	来核实 `对方身份`

`ECDH密钥交换算法`  ：ECC算法和DH结合使用，用于密钥磋商

#### 	**非对称加密算法：**

​			密钥成对出现（私钥、公钥），私钥只有自己知道，不在网络中传输；而公钥可以公开。把公钥给发送方。一般是加密对称性加密的秘钥。  相比对称加密速度较慢，典型的非对称加密算法有：`RSA`、DSA



数字签名：**仍然公布公钥，但是用你的私钥加密数据，然后把加密的数据公布出去，这就是数字签名**。主要目的是证明身份。



***1、***Bob 生成公钥和私钥，然后把公钥公布出去，私钥自己保留。

**2、**用私钥加密数据作为签名，然后将数据附带着签名一同发布出去。

***3***、Alice 收到数据和签名，需要检查此份数据是否是 Bob 所发出，于是用 Bob 之前发出的公钥尝试解密签名，**将收到的数据和签名解密后的结果作对比**，如果完全相同，说明数据没被篡改，且确实由 Bob 发出



公钥证书：公钥+签名（引入可信任的第三方）

证书认证的流程大致如下：

***1、***Bob 去可信任的认证机构证实本人真实身份，并提供自己的公钥。

2、Alice 想跟 Bob 通信，首先向认证机构请求 Bob 的公钥，认证机构会把一张证书（Bob 的公钥以及机构对其公钥的签名）发送给 Alice。

***3、***Alice 检查签名，确定该公钥确实由这家认证机构发送，中途未被篡改。

***4、***Alice 通过这个公钥加密数据，开始和 Bob 通信。

![1](https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdEnCxMxGb3LgzNf4aunA3gowuGUIeK4bxTSovSsR0PSCPYcLy773DkE1V4biclWQcqPzFBibVDzfgMQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



## TCP

### 报文格式

![](复习笔记.assets/27194088468_4cb0141fc8_b.jpg)

头部字段：

- 序号（32bit）：传输方向上字节流的字节编号。初始时序号会被设置一个随机的初始值（`ISN`），之后每次发送数据时，序号值 = ISN + 数据在整个字节流中的偏移。假设A -> B且ISN = 1024，第一段数据512字节已经到B，则第二段数据发送时序号为1024 + 512。用于解决网络包乱序问题。

- 确认号（32bit）：接收方对发送方TCP报文段的响应，其值是收到的序号值 + 1。

- 首部长（4bit）：标识首部有多少个4字节 * 首部长，最大为15，即60字节。

- 标志位（6bit）：
  - URG：标志紧急指针是否有效。

  - `ACK`：标志确认号是否有效（确认报文段）。用于解决丢包问题。

  - PSH：提示接收端立即从缓冲读走数据。

  - RST：表示要求对方重新建立连接（复位报文段）。

  - `SYN`：表示请求建立一个连接（连接报文段）。

  - `FIN`：表示关闭连接（断开报文段）。

- 窗口（16bit）：`接收窗口`。用于告知对方（发送方）本方的缓冲还能接收多少字节数据。用于解决流控。

- 校验和（16bit）：接收端用CRC检验整个报文段有无损坏。



## TCP粘包现象原因和解决方法

​	**TCP粘包是指**：发送方发送的若干包数据到接收方接收时**粘成一包**

​	**发送方原因：**

- TCP默认使用`Nagle算法`（主要作用：减少网络中报文段的数量），而Nagle算法主要做两件事：

​			只有上一个分组得到确认，才会发送下一个分组
​			收集多个小分组，在一个确认到来时一起发送
​		Nagle算法造成了发送方可能会出现粘包问题。

- 应用程序写入数据的字节大小大于套接字发送缓冲区的大小.
- 进行MSS大小的TCP分段。( MSS=TCP报文段长度-TCP首部长度)
- 以太网的payload大于MTU进行IP分片。（ MTU指：一种通信协议的某一层上面所能通过的最大数据包大小。）

​	**接收方原因：**

​			TCP接收到数据包时，并不会马上交到应用层进行处理，或者说应用层并不会立即处理。实际上,TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果`TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。`

​	**解决粘包问题：**

​		最本质原因在与`接收对等方无法分辨消息与消息之间的边界在哪，通过使用某种方案给出边界`，例如：

- 发送`定长包`。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。
- `包尾加上\r\n标记`。FTP协议正是这么做的。但问题在于如果数据正文中也含有\r\n，则会误判为消息的边界。
- `包头加上包体长度`。包头是定长的4个字节，说明了  包体的长度。接收对等方先接收包体长度，依据包体长度来接收包体。
- 使用复杂的协议：如RTMP协议等。

## TCP连接

一个 TCP 连接是可以`发送多个` HTTP 请求的。

http 1.1 :一次建立连接 多次请求资源。但单个 TCP 连接在同一时刻只能处理一个请求。

Chrome 最多允许对同一个 Host 建立六个 TCP 连接。(不同的浏览器有一些区别。)

### TCP状态变迁图

![](复习笔记.assets/QQ截图20210317164731.png)

## 三次握手



![1](https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe7Uj5vVP4B82jibfFeD6FwMfqDGxQh6639MuYAKKsrQHqWNLYUGHnLnMbyuXjvk5nswCCD9lrjHMBQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

![](复习笔记.assets/net-55-1.png)

### 流程

- 初始状态：客户端处于 `closed(关闭)`状态，服务器处于 `listen(监听)` 状态。
- 第一次握手：客户端发送请求报文将 `SYN = 1`同步序列号和初始化序列号`seq = x`发送给服务端，发送完之后客户端处于`SYN_Send`状态。（验证了客户端的发送能力和服务端的接收能力）
- 第二次握手：服务端受到 `SYN` 请求报文之后，如果同意连接，会以自己的同步序列号`SYN(服务端) = 1`、初始化序列号 `seq = y`和确认序列号（期望下次收到的数据包）`ack = x+ 1` 以及确认号`ACK = 1`报文作为应答，服务器为`SYN_Receive`状态。（问题来了，两次握手之后，站在客户端角度上思考：我发送和接收都ok，服务端的发送和接收也都ok。但是站在服务端的角度思考：哎呀，我服务端接收ok，但是我不清楚我的发送ok不ok呀，而且我还不知道你接受能力如何呢？所以老哥，你需要给我三次握手来传个话告诉我一声。你要是不告诉我，万一我认为你跑了，然后我可能出于安全性的考虑继续给你发一次，看看你回不回我。）
- 第三次握手： 客户端接收到服务端的 `SYN + ACK`之后，知道可以下次可以发送了下一序列的数据包了，然后发送同步序列号 `ack = y + 1`和数据包的序列号 `seq = x + 1`以及确认号`ACK = 1`确认包作为应答，客户端转为`established`状态。（分别站在双方的角度上思考，各自ok）

> 前两次不能携带数据，第三次可以

### 为什么必须要3次？

确认发送方与接收方双方的发送能力和接收能力。

`防止已经失效的链接请求报文段突然又传到了服务器`。假设出现一种异常：A发出的第一个连接的请求报文段没有丢失，而是在网络中的某个结点滞留了，一直延迟到连接释放以后的某个时间才到达B，本来这是一个早已经失效的报文段，但是B接收到失效的连接请求后，就会误以为A又发送了一次新的连接请求，于是就向A发出确认报文段，同意建立了连接。如果没有三次握手，新的连接就建立了，之后会一直等A发送数据，资源就会被白白的浪费了。

### 半连接队列？

服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个**队列**里，我们把这种队列称之为**半连接队列**。

当然还有一个**全连接队列**，就是`已经完成三次握手，建立起连接的就会放在全连接队列中`。如果队列满了就有可能会出现丢包现象。

### 第三次握手失败

客户端收到服务端的SYNACK应答后，其状态变成ESTABLISHED,并会发送ACK包给服务端，若ACK报文丢失，过了超时计时器后，那么服务端会重新发送`SYNACK`包，重传次数根据`/proc/sys/net/ipv4/tcp_synack_retries`来指定，默认是`5`次。如果重传指定次数到了后，仍然未收到`ACK`应答，那么一段时间后，`Server`自动关闭这个连接。

> 如果一个`ACK 报文`丢失了，但它的下一个数据包没有丢失，那么连接正常，否则，连接会被重置。
>
> 错误会发送RST报文（重置）

### SYN攻击

​	服务器利用`SYNACK 报文`的时候，会为客户端请求分配缓存，攻击者使用一批虚假的`ip`向服务器大量地发建立`TCP 连接`的请求，服务器为这些`虚假ip`分配了缓存后，处在`SYN_RCVD`状态，存放在`半连接队列`中；另外，服务器发送的请求又不可能得到回复（ip都是假的，能回复就有鬼了），只能不断地`重发请求`，直到达到设定的时间/次数后，才会关闭。`SYN 攻击是一种典型的 DoS/DDoS 攻击。`

服务器不断为这些`半开连接`分配资源（但从未使用），导致服务器的连接资源被消耗殆尽。

检测SYN攻击：看到大量的半连接状态、特备是源IP是随机的，在Linux上使用 netstats命令检测

```
netstat -n -p TCP | grep SYN_RECV
```

解决方法：

- 可以使用`SYN Cookie`进行有效地防御。（暂不分配资源，利用`SYN 报文`的`源`和`目的地IP`和`端口`，以及服务器存储的一个`秘密数`，使用它们进行散列，得到`server_isn`，然后附着在`SYNACK 报文`中发送给客户端） 

  但由于`服务器不保存连接的半开状态`，就`丧失`了`重发SYN-ACK消息`的能力，这一方面会降低正常用户的连接成功率。（第三次ACK失败）需要`上层应用采取策略`。

- `缩短超时（SYN Timeout）时间`

- 增加最大半连接数

## 四次挥手

![2](https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe7Uj5vVP4B82jibfFeD6FwMfVEvMD09GjbNAz63BBic5Hpe29DicbFt4IurwlX55WysP5ouoRxvIic2hw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

原因：由TCP的`半关闭`（half-close）造成的。所谓的半关闭，其实就是`TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。`

流程：

- 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 `FIN_WAIT1` 状态。 即发出**连接释放报文段**（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。
- 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 `CLOSE_WAIT` 状态。 即服务端收到连接释放报文段后即发出**确认报文段**（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。
- 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 `LAST_ACK` 的状态。 即服务端没有要向客户端发出的数据，服务端发出**连接释放报文段**（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。
- 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 `TIME_WAIT` 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 `CLOSED` 状态。 即客户端收到服务端的连接释放报文段后，对此发出**确认报文段**（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。

### 四次挥手中客户端为何会出现 time-wait 现象？

- `为了保证客户端发送的最后一个ACK报文能够到达服务器端`.因为这个ACK报文可能会丢失，然后B收不到A发出的ACK报文段的确认。B会超时重传这个FIN+ACK的报文段。A在2MSL重新传一次确认，重新启动2MSL计时器，最后AB都进入CLOSED状态。
- `防止“已失效的连接请求报文段”出现在本连接中。`A在发送完最后一个ACK报文段后，在经过2MSL（`报文最大存活时间`），就可以使本连接持续的时间内所产生的`所有报文段都从网络中消失`，这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

服务端收到FIN报文时，很可能不会立即关闭SOCKET，先回复ACK报文，等到所以报文都发送/接收完毕，在发送FIN报文。

**如何查看TIME-WAIT状态的链接数量？**		

​	netstat -an |grep TIME_WAIT|wc -l  查看连接数等待time_wait状态连接数

**为什么会TIME_WAIT过多？解决方法是怎样的？**

​	**可能原因：** 高并发短连接的TCP服务器上，当服务器处理完请求后立刻按照主动正常关闭连接  （端口不够用）

​	**解决：**负载均衡服务器；`Web服务器首先关闭来自负载均衡服务器的连接`。通过修改内核参数，维持长连接

**为什么会CLOSE_WAIT过多？解决方法是怎样的？**

可能原因：服务端接口耗时较长，客户端主动断开了连接

解决：`代码问题。`查看代码 为什么耗时长。

## TCP

### 重传机制：

- 超时重传：（发生情况：数据包丢失、确认应答丢失）RTO 略大于 RTT

- 快速重传：客户端收到3次一样的ack，就会**在定时器过期之前，重传丢失的数据包 **。只是解决了超时问题，但不知道要重传多少

- SACK ：TCP头部，将缓存的地图发送给发送方，这样发送方就知道收到了哪些数据，可以只重传丢失的数据

  `net.ipv4.tcp_sack` 

- D-SACK：主要**使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。**

  `net.ipv4.tcp_dsack` 

  好处：可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;
  			可以知道是不是「发送方」的数据包被网络延迟了;
  			可以知道网络中是不是把「发送方」的数据包给复制了;

### 滑动窗口

流量控制属于`通信双方协商`

窗口大小就是指**无需等待确认应答，而可以继续发送数据的最大值**。大小取决于`接收方窗口大小`。TCP字段`Window`告知

累计应答

![1](复习笔记.assets/滑动窗口.png)

使用三个指针来跟踪在四个传输类别中的每一个类别中的字节。其中两个指针是绝对指针（指特定的序列号），一个是相对指针（需要做偏移）。

> 发送窗口和接收窗口中所存放的字节数，都是放在操作系统内存缓冲区中的，而操作系统的缓冲区，会**被操作系统调整**。
>
> 先收缩窗口，在减少缓存

### 拥塞控制

涉及 `通信链路全局`

**拥塞窗口 cwnd**是发送方维护的一个的状态变量，它会根据**网络的拥塞程度动态变化的**

- 只要网络中没有出现拥塞，`cwnd` 就会增大；
- 但网络中出现了拥塞，`cwnd` 就减少；

方法：

1. `慢启动` ：1）当发送方`每`收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1

   2）`每当过了一个往返延迟时间RTT(Round-Trip Time)，cwnd大小直接翻倍`，乘以2，呈指数让升 （总体）。

   >    有一个叫慢启动门限 `ssthresh` （slow start threshold）状态变量。（一般大小是 `65535` 字节。）
   >
   > - 当 `cwnd` < `ssthresh` 时，使用慢启动算法。
   > - 当 `cwnd` >= `ssthresh` 时，就会使用「拥塞避免算法」。

2. `拥塞避免` ：1) 收到一个ACK，则 对每个报文  cwnd = cwnd + 1 / cwnd
                           2) 每当过了一个往返延迟时间RTT，cwnd大小加一（总体）。

   > 通过丢包判断网络是否进入拥塞状态

3. `拥塞发生` ：两种判定方式：

   1). `超时重传`: 发送一个数据以后就开启一个计时器，在一定时间内如果没有得到发送数据报的ACK报文，那么就重新发送数据，直到发送成功为止。  

   则 ：`ssthresh` 设为 cwnd/2，`cwnd` 重置为 1，进入慢启动状态。  效果不好。

   2）三次重复确认ACK（3个是确保  丢包产生的）: 使用快速恢复算法

4. `快速恢复`： 三次累计应答，`cwnd`=`cwnd/2`，`ssthresh=cwnd`  然后拥塞窗口 `cwnd = ssthresh + 3` （ 3 的意思是确认有 3 个数据包被收到了），重传丢失的数据包；如果再收到重复的 ACK，那么 `cwnd` 增加 1；
   如果收到新数据的 ACK 后，把 `cwnd` 设置为 `ssthresh` （减半后的cwnd）的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；

![1](复习笔记.assets/拥塞控制.png)



### 系统调用过程

![](复习笔记.assets/1567424004017.png)



## UDP

没有序号

![image-20210905112848834](复习笔记.assets/image-20210905112848834.png)

### 发送字节数

- 普通局域网

  MTU(最大传输单元)：1500，`链路层的数据区，并不包括链路层的首部和尾部的18个字节`

  IP数据报首部：20

  UDP首部：8

  所以可以发送`1472`（多了就要分片）

- Internet上的标准MTU值为576字节，所以此时 为 `548字节(576-8-20)以内`

### 要想可靠

在 应用层实现    确认机制、重传机制、窗口确认机制

开源实现：

- RUDP
- RTP
- UDT

## IP

`不可靠 无连接`

利用TTL(TIME TO LIVE)控制数据传输的时延。

IP地址：{<网络号>,<子网号>,<主机号>}   对外仍是 通过 网络号路由& 

IP地址与子网掩码相 & 可求出 网络号

子网掩码`取反`运算，然后与网络地址进行`或`运算，得到广播地址。

 默认子网掩码：

- A类地址： 255.0.0.0
- B类地址： 255.255.0.0
- C类地址： 255.255.255.0

### 报文

源IP、目的IP、首部长、总长度、片偏移、检验和

![](复习笔记.assets/u=1614312792,1954581760&fm=26&gp=0.jpg)

## Socket

![](复习笔记.assets/socket2.jpg)

 Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。

![](复习笔记.assets/socket3.jpg)



```
int socket(int domain, int type, int protocol);
//创建一个socket描述符 在协议族空间中,要想赋值一个地址，要使用 bind()
```

- domain：协议族
- type
- protocol：协议

```
// 一个地址族中的特定地址赋给socket
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

connect是进行 tcp 3次握手



### Java Socket里面close()和shutdown()有啥区别？

全双工和半双工的区别。

close把描述符的引用计数减1，仅在该计数变为0时关闭套接字。shutdown可以不管引用计数就激发TCP的正常连接终止序列

close终止读和写两个方向的数据发送。TCP是全双工的，有时候需要告知对方已经完成了数据传送，即使对方仍有数据要发送给我们。



## Cookie,Seesion

HTTP 协议是**无状态**的，Cookie 是**服务器发送到用户浏览器并保存在本地的一小块数据**  （只能存储 ASCII 码字符串）

（新的浏览器 API 已经允许开发者直接将数据存储到`本地`，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。）

>  一个 cookie 可以认为是一个「变量」，形如 name=value，存储在浏览器；一个 session 可以理解为一种数据结构，多数情况是「映射」（键值对），存储在服务器上。

### Cookie用途？

- `会话状态管理`（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- `个性化设置`（如用户自定义设置、主题等）
- `浏览器行为跟踪`（如跟踪分析用户行为等）

`Session 可以存储在服务器上的文件、数据库或者内存中`。（`可以存储任何类型的数据`）也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。



### 使用 Session 维护用户登录状态的过程：

1. 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；
2. 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；
3. 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；
4. 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。

> 注意：Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要`经常重新生成 Session ID`。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。



### 若Cookie被禁用方法

- URL重写，把session id直接附加在URL路径后面
- 表单隐藏技术，添加一个隐藏字段（session id）

### 在多台web服务器上共享session？

使用Redis缓存

### Token

通过CPU计算 来 避免 存储session

通过UUID   密钥 加密数据 生成签名，  再和 数据 一起做为 token  ，收到后解密  

## 重定向和转发区别

​	**重定向：redirect：**

​			发送状态码，地址栏发生变化	

​			重定向可以访问其他站点（服务器）的资源

​			重定向是两次请求。不能使用request对象来共享数据

​	**转发：forward：**

​			是`服务器请求资源`,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的

​            转发地址栏路径不变

​			转发只能访问当前服务器下的资源

​			转发是一次请求，可以使用request对象`共享`数据



## 攻击

### CSRF

（Cross-site request forgery）：跨站请求伪造。

![](复习笔记.assets/941968-20190422203527996-279231194.jpg)

- 登录受信任网站A，并在本地生成Cookie。
- 在不登出A的情况下，访问危险网站B

防御：

- token验证

### XSS

XSS（Cross Site Scripting）：跨域脚本攻击。

不需要你做任何的登录认证，它会通过合法的操作（比如在url中输入、在评论框中输入），向你的页面注入`脚本`（可能是js、hmtl代码块等）。

结果：盗用Cookie破坏页面的正常结构，插入广告等恶意内容D-doss攻击

#### SQL注入攻击

攻击者在HTTP请求中注入恶意的SQL代码，`服务器使用参数构建数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行。`
用户登录，输入用户名 lianggzone，密码 ‘ or ‘1’=’1 ，如果此时使用参数构造的方式，就会出现
select * from user where name = ‘lianggzone’ and password = ‘’ or ‘1’=‘1’
不管用户名和密码是什么内容，使查询出来的用户列表不为空。如何防范SQL注入攻击使用预编译的PrepareStatement是必须的，但是一般我们会从两个方面同时入手。
Web端
1）`有效性检验`。
2）`限制字符串输入的长度`。
服务端
1）不用拼接SQL字符串。
2）`使用预编译的PrepareStatement`。
3）有效性检验。(为什么服务端还要做有效性检验？第一准则，外部都是不可信的，防止攻击者绕过Web端请求)
4）`过滤SQL需要的参数中的特殊字符。比如单引号、双引号。`

### DDoS

分布式拒绝服务攻击

## RARP？工作原理

概括： `反向地址转换协议，网络层协议`，RARP与ARP工作方式相反。 RARP使只知道自己硬件地址的主机能够知道其IP地址。RARP发出要反向解释的物理地址并希望返回其IP地址，应答包括能够提供所需信息的RARP服务器发出的IP地址。
原理：
(1)网络上的每台设备都会有一个独一无二的硬件地址，通常是由设备厂商分配的MAC地址。主机从网卡上读取MAC地址，然后在网络上发送一个RARP请求的广播数据包，请求RARP服务器回复该主机的IP地址。

(2)RARP服务器收到了RARP请求数据包，为其分配IP地址，并将RARP回应发送给主机。

(3)PC1收到RARP回应后，就使用得到的IP地址进行通讯。

## 端口有效范围

0-1023为知名端口号，比如其中HTTP是80，FTP是20（数据端口）、21（控制端口）

UDP和TCP报头使用两个字节存放端口号，所以端口号的有效范围是从0到65535。动态端口的范围是从1024到65535

# :book:  多线程并发

- *JUC*: java.util .concurrent工具包 

- JMX ：Java Management Extensions，即`Java管理扩展`，是一个为应用程序、设备、系统等植入管理功能的框架

- MXBean：引用预定义数据类型的MBean

实现线程安全的方式：

- 不可变：final、String、枚举类型
- 互斥同步：synchronized 和 ReentrantLock
- 非阻塞同步：CAS、AtomicInteger（调用了 Unsafe 类的 CAS 操作）

## 创建线程方式：

```java

1. extends Thread类; 通过Thread类的start方法 启动一个新的线程，并执行run（）方法
2. implements Runnable接口
3.通过 Callable、线程池、Future 
 - 创建 Callable 接口实现类，重写 call 方法
 - 创建 Callable 类的实例，使用 FutureTask 类对象包装该实例，FutueTask 对象封装了Callable 对象 call 方法的返回值
 - 将 FutureTask 作为 Thread 对象的 target 属性传入，并启动线程。
    调用 FutureTask 对象的 get 方法，获取返回值。
4. 线程池 创建线程（不推荐）   1.缓存队列设置最大，导致内存撑爆 2.最大线程数量设置成最大  
 
    
无返回值的实现Runnable接口，有返回值的实现Callable接口（可以获取一个 Future (接口 FutureTask是其实现类)的对象 然后get 获取对象）

顶级接口是 Executor；真正的线程池接口是 ExecutorService
                    
```

### 创建多进程

- Runtime的exec()方法
- ProcessBuilder的start()方法

## 线程状态：

Java虚拟机的线程状态，不能反映在特定操作系统下的状态

> 1. NEW: 线程创建之后，但是还没有启动(not yet started)。
>
> 2. RUNNABLE: 正在Java虚拟机下跑任务的线程的状态。对应 running与ready
>
> 3. BLOCKED: 阻塞状态，**等待锁**的释放
>
> 4. WAITING: 等待状态       需要其他线程唤醒再变成RUNNABLE状态
>
>    - 没有timeout的 object.wait()      / Condition.await()   释放锁
>    - 没有timeout的Thread.join()       不会释放锁，会一直等待当前线程执行完毕（转换为TERMINATED状态）
>    - LockSupport.park()     阻塞当前线程    提供了基本的线程同步原语，调用了unsafe类
>
> 5. TIMED_WAITING: 限期等待   有等待时间的等待状态
>
>    - Thread.sleep((long millis)     不会释放锁
>    - 有timeout的object.wait(long timeout)
>    - 有timeout的Thread.join(long millis)       使当前线程执行指定时间，并且使线程进入TIMED_WAITING状态。
>    - LockSupport.parkNanos(long nanos)： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间；
>    - LockSupport.parkUntil(long deadline)  ：禁止线程进行调度指定时间；
>
> 6. TERMINATED: 线程中止的状态，这个线程已经完整地执行了它的任务



<img src="复习笔记.assets/677054-20170401135928086-1745189627.jpg" title="线程状态转换图" style="zoom:200%;" />



jstack`查看线程状态`

![1](https://images2015.cnblogs.com/blog/677054/201703/677054-20170325175602158-1635644853.jpg "VisualVM线程监控线程状态"与“Java线程状态"对应关系")

> - start（）：一个新线程将会被创建，然后自动执行run方法；`不可以多次调用`
>- run（）：当前线程会当成普通方法去 运行run方法 ，不是多线程



> **阻塞”与“等待”的区别：**
>
> （1）“阻塞”状态是等待着获取到一个排他锁，进入“阻塞”状态都是`被动`的，离开“阻塞”状态是因为其它线程释放了锁，不阻塞了；
>
> （2）“等待”状态是在等待一段时间 或者 唤醒动作的发生，进入“等待”状态是`主动`的
>
> 如主动调用Object.wait()，如无法获取到ReentraantLock，主动调用LockSupport.park()，如主线程主动调用 subThread.join()，让主线程等待子线程执行完毕再执行
>
> 离开“等待”状态是因为其它线程发生了唤醒动作或者到达了等待时间

> sleep 与 wait 区别  
>
> sleep：Thread 类，线程`不会释放对象锁` 带参  `自动苏醒`
>
> wait：Object类里，`会放弃对象锁`，进入等待对象的等待锁定池，`不会自动苏醒`，要调用notify方法通知，进入就绪状态  可不带参，  只能在同步方法或同步块里执行

> 后台线程：
> 守护线程（服务线程）：为用户线程提供公共服务，setDaemon（true）来设置 
>
> 如果所有的非守护线程都结束了，这个守护线程也会自动结束。
>
> 例：垃圾回收线程、main()

> ### yield()
>
> 对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。
>
> ```java
> public void run() {
>     Thread.yield();
> }
> ```

```java
// Thread类源码 

// 片段1 - init方法
private void init(ThreadGroup g, Runnable target, String name,
                      long stackSize, AccessControlContext acc,
                      boolean inheritThreadLocals)
   /*
   g：线程组，指定这个线程是在哪个线程组下；

   target：指定要执行的任务；

   name：线程的名字，多个线程的名字是可以重复的。如果不指定名字，见片段2；

   	acc：见片段3，用于初始化私有变量inheritedAccessControlContext。
   */

// 片段2 - 构造函数调用init方法
public Thread(Runnable target) {
    init(null, target, "Thread-" + nextThreadNum(), 0);
}

// 片段3 - 使用在init方法里初始化AccessControlContext类型的私有属性
this.inheritedAccessControlContext = 
    acc != null ? acc : AccessController.getContext();

// 片段4 - 两个对用于支持ThreadLocal的私有属性
ThreadLocal.ThreadLocalMap threadLocals = null;
ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;

//常用方法
currentThread()：静态方法，返回对当前正在执行的线程对象的引用；
start()：开始执行线程的方法，java虚拟机会调用线程内的run()方法；
yield()：当前线程愿意让出对当前处理器的占用。这里需要注意的是，就算当前线程调用了yield()方法，程序在调度的时候，也还有可能继续运行这个线程的；
sleep()：静态方法，使当前线程睡眠一段时间；
join()：使当前线程等待另一个线程执行完毕之后再继续执行，内部调用的是Object类的wait方法实现的；
setPriority():设置优先级，但具体调用顺序还是根据os调度算法决定
    
执行main()方法线程（默认是主线程）的名字是main，如果在new Thread时没有显式指定，那么默认将父线程（当前执行new Thread的线程）线程组设置为自己的线程组。
    
    
    向下引用  
    线程组是一个树状的结构，每个线程组下面可以有多个线程或者线程组。线程组可以起到统一控制线程的优先级和检查线程的权限的作用。
```

## 互斥同步

Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。

线程间通信(通过JMM控制)：锁    等待/通知机制  信号量（`volatile` 保证内存可见性、并不能保证操作的原子性       禁止与普通变量重排序（插入内存屏障） ）  管道（`PipedWriter`、 `PipedReader`、 `PipedOutputStream`、 `PipedInputStream`。其中，前面两个是基于字符的，后面两个是基于字节流的） join（）、sleep（）

### 协作

- join()：使当前线程等待另一个线程执行完毕之后再继续执行，内部调用的是Object类的wait方法实现的；
- wait() notify() notifyAll()
-  await() signal() signalAll()

## 引用的分类


> 1. 强引用：最普遍，绝对不会回收
> 2. 软引用：可有可无，**如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存**。加速了回收速度；
> 3. 弱引用：类似软引用，但具有更短暂的生命周期。无论内存够不够用，都会被垃圾回收。与`引用队列`联合使用（下一次GC就会被回收）
> 4. 虚引用：**和没有任何引用一样，在任何时候都可能被垃圾回收**，与引用队列联合使用（在这个对象被GC时收到一个系统通知）

## ThreadLocal



```java
//Thread 类源码
public class Thread implements Runnable {
......
//与此线程有关的ThreadLocal值。由ThreadLocal类维护
ThreadLocal.ThreadLocalMap threadLocals = null;
//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护
//当前线程可以存取副本值，而且它的子线程也可以存取这个副本值
ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
......
}
```

ThreadLocal：一个`本地线程副本变量工具类`。存储每个线程的私有数据

​                           为用来解决数据库连接、Session管理等

​       静态内部类：ThreadLocalMap，它的静态内部类是Entry类，其key的类型是ThreadLocal（实例本身  `弱引用` ==null后 垃圾回收时可能会被清理掉），value是Object（强引用）

   所以不用了 就 remove（Entry）



两种并发模型：

![1](http://concurrent.redspider.group/article/02/imgs/%E4%B8%A4%E7%A7%8D%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83.png)

Java使用共享内存并发模型

## Java内存模型

### 内存间交互操作

![](复习笔记.assets/8b7ebbad-9604-4375-84e3-f412099d170c.png)

- read：把一个变量的值从主内存传输到工作内存中
- load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中
- use：把工作内存中一个变量的值传递给执行引擎
- assign：把一个从执行引擎接收到的值赋给工作内存的变量
- store：把工作内存的一个变量的值传送到主内存中
- write：在 store 之后执行，把 store 得到的值放入主内存的变量中
- lock：作用于主内存的变量
- unlock

### 三大特性

- 原子性： 通过原子类AtomicInteger、synchronized 互斥锁
- 可见性：一个线程修改了共享变量的值，其它线程能够立即得知这个修改。
  - volatile
  - synchronized
  - final
- 有序性：在本线程内观察，所有操作都是有序的。
  - volatile： 添加内存屏障来禁止指令重排
  - synchronized



#### 指令重排：

提升性能  有编译器优化重排、指令并行重排、内存系统重排

**指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致**

顺序一致性模型也需要 `同步`

happens-before关系保证正确同步的多线程程序的执行结果不被重排序改变。

> JVM 通过内存屏障限制处理器的重排序
>
> 内存屏障：读屏障（Load Barrier）和写屏障（Store Barrier）
>
> 作用：
>
> 1. 阻止屏障两侧的指令重排序；
> 2. 强制把写缓冲区/高速缓存中的脏数据等写回主内存，或者让缓存中相应的数据失效。

#### 先行发生原则

一个操作无需控制就能先于另一个操作完成。

- 管理锁定原则：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。

  ![](复习笔记.assets/8996a537-7c4a-4ec8-a3b7-7ef1798eae26.png)

- volatile 变量规则: 对一个 volatile 变量的`写操作`先行发生于后面对这个变量的读操作

- 线程加入原则：Thread 对象的`结束`先行发生于 join() 方法返回

  

## 线程中断

​	线程中断机制是一种协作机制。通过中断操作并不能直接终止一个线程，而是通知需要被中断的线程自行处理。

sleep() 可能会抛出 InterruptedException

可中断：在线程中断时可能会抛出`InterruptedException`，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。

方法：

- Thread.interrupt()：中断线程。这里的中断线程`并不会立即停止线程`，而是设置线程的中断状态为true（默认是flase）；
- Thread.interrupted()：`返回当前线程是否被中断。`线程的中断状态受这个方法的影响，意思是调用一次使线程中断状态设置为true，连续调用两次会使得这个线程的中断状态重新转为false；
- Thread.isInterrupted()：返回当前线程是否被中断。与上面方法不同的是调用这个方法并不会影响线程的中断状态。



调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。

## synchronized：

可修饰 实例方法、静态方法（锁住的是类）、代码块。   可保证原子性、可见性  。 用于访问资源的同步性

```java

// 关键字在实例方法上，锁为当前实例
public synchronized void instanceLock() {
    // code
    //临界区就是整个方法内部
}

// 关键字在静态方法上，锁为当前Class对象
public static synchronized void classLock() {
    // code
}

// 关键字在代码块上，锁为括号里面的对象
public void blockLock() {
    Object o = new Object();
    synchronized (o) {
        // code
    }
}
```

本质：获取监视器锁（1.同步语句块：monitorenter指令  若锁计时器为0 则获取到 设为1否则就阻塞等待   ； monitorexit指令：设为0 释放            2.同步方法：ACC_SYNCHRONIZED   同步标识）

## volatile

线程同步的轻量级实现  只作用于变量，保证可见性 但不保证原子性

原理： 写之后 store 写回主内存，读之前load 从主内存中读：

## 锁

基于对象的（类锁也是一种对象锁）

> 锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。
>
> ![](复习笔记.assets/20200606113736103.png)
>
> 锁可以升级  
>
> 降级条件苛刻：Stop The World期间，当JVM进入安全点的时候，会检查是否有闲置的锁，然后进行降级

对象头：

- 乐观锁  （无锁）认为读多写少 ，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据

  - 写时先读出当前**版本号**，加锁
  - 通过CAS: Compare and Swap   更新的原子操作   比较当前值跟传入值是否一样，一样则更新，否则失败
  
- 悲观锁 写多读少 每次读写数据都会加锁  

  Synchronized  AQS框架下是先尝试获取CAS锁，失败则转换为悲观锁，如RetreenLock  

-  自旋锁

   如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。  
   
   `适应性自选锁`：自旋时间由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定  

- Synchronized 同步锁
   把任意一个非 NULL 的对象当作锁。 他属于独占式的悲观锁，同时属于可重入锁。锁在对象头。 `不可中断、非公平`

- 非公平锁
   按随机、就近原则分配锁，可能发生线程饥饿
   
- 公平锁

   加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得  （维护队列）

- 可重入锁（递归锁）

   线程对资源重复加锁，同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响  
   
   防止自己锁死自己
   
   当一个线程获得该锁后若未释放前想要再次获取该锁，则可以直接获取不用等待，我们只需要把锁的次数加一即可，释放一次锁次数就减一，直到次数为零，其它线程就可以继续竞争该锁了。
   
- 读写锁

   读时用读锁，写时用写锁。

- 共享锁和独占锁

   独占锁：每次只能有一个线程能持有锁  

   共享锁：
   
- 重量级锁（Mutex Lock）

   依赖于操作系统 Mutex Lock 所实现的锁  

- 轻量级锁 

   获取及释放依赖多次 CAS 原子指令  。多个线程在不同时段获取同一把锁，即不存在锁竞争

   适应性自旋：如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。

- 偏向锁

   在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。**等到竞争出现才释放锁**   
   
- 分段锁



> Contention List：所有请求锁的线程将被首先放置到该竞争队列
> Entry List：Contention List中那些有资格成为候选人的线程被移到Entry List
> Wait Set：那些调用wait方法被阻塞的线程被放置到Wait Set
> OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为OnDeck
> Owner：获得锁的线程称为Owner
> !Owner：释放锁的线程

> 当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个ObjectWaiter对象插入到Contention List的队列的队首，然后调用park函数挂起当前线程。
>
> 当线程释放锁时，会从Contention List或EntryList中挑选一个线程唤醒，被选中的线程叫做Heir presumptive即假定继承人，假定继承人被唤醒后会尝试获得锁，但synchronized是非公平的，所以假定继承人不一定能获得锁。这是因为对于重量级锁，线程先自旋尝试获得锁，这样做的目的是为了减少执行操作系统同步操作带来的开销。如果自旋不成功再进入等待队列。这对那些已经在等待队列中的线程来说，稍微显得不公平，还有一个不公平的地方是自旋线程可能会抢占了Ready线程的锁。
>
> 如果线程获得锁后调用Object.wait方法，则会将线程加入到WaitSet中，当被Object.notify唤醒后，会将线程从WaitSet移动到Contention List或EntryList中去。需要注意的是，当调用一个锁对象的wait或notify方法时，如当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁。

### 锁升级过程：

> 每一个线程在准备获取共享资源时： 第一步，检查MarkWord里面是不是放的自己的ThreadId ,如果是，表示当前线程是处于 “偏向锁” 。
>
> 第二步，如果MarkWord不是自己的ThreadId，锁升级，这时候，用CAS来执行切换，新的线程根据MarkWord里面现有的ThreadId，通知之前线程暂停，之前线程将Markword的内容置为空。
>
> 第三步，两个线程都把锁对象的HashCode复制到自己新建的用于存储锁的记录空间，接着开始通过CAS操作， 把锁对象的MarKword的内容修改为自己新建的记录空间的地址的方式竞争MarkWord。
>
> 第四步，第三步中成功执行CAS的获得资源，失败的则进入自旋 。
>
> 第五步，自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于 轻量级锁的状态，如果自旋失败 。
>
> 第六步，进入重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己。

### ReentrantLock

> 底层使用了 CAS+AQS 队列实现
>
> Lock接口的实现类
>
> API级别
>
> 通过方法 lock()与 unlock()来进行加锁与解锁操作。需要手动解锁（在finally控制块）
>
> `可中断`，可公平锁（需要维护队列，通过AQS队列的先后顺序获取锁，缺点是会造成大量线程上下文切换），可非公平锁（默认的lock（）采用非公平锁，可以直接抢占，所以效率更高）多个锁  独占锁 可重入
>
> 
>
> lock（）函数：如果成功通过CAS修改了state，指定当前线程为该锁的独占线程，标志自己成功获取锁。
>
> 如果CAS失败的话，调用acquire();（首先，调用tryAcquire()，会尝试再次通过CAS修改state为1，
>
> 如果失败而且发现锁是被当前线程占用的，就执行重入（state++）；
>
> 如果锁是被其他线程占有，那么当前线程执行tryAcquire返回失败，并且执行addWaiter()进入等待队列，并挂起自己interrupt()。）
>
> unlock（）：释放时候，state--，通过state==0判断锁是否完全被释放。
>
> 成功释放锁的话，唤起一个被挂起的线程



ReentrantReadWriteLock实现了读写锁，但写饥饿

StampedLock：**在读的时候如果发生了写，应该通过重试的方式来获取新的值，而不应该阻塞写操作。这种模式也就是典型的无锁编程思想，和CAS自旋的思想一样**

### 锁优化：

> - 减少锁持有时间 （有线程安全要求  ）
> - 自旋锁
> - 减少锁粒度 （大对象拆分）
> - 锁分离 （读写锁）
> - 锁粗化：`增加锁持有的时间` ，对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部
> - 锁细化：`减少锁持有的时间`，减少加锁范围。
> - 锁消除：对于被检测出`不可能存在竞争`的共享数据的锁进行消除

### CAS

> ​        CAS(V,E,N)。 V 表示要更新的变量(内存值)， E 表示预期值(旧的)， N 表示新值。
>
> 当且仅当 V 值等于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后， CAS 返回当前 V 的真实值    。
>
> 造成问题：
>
> 1. 会造成ABA问题。（即T1读取内存变量为A,T2修改内存变量为B,T2又修改内存变量为A,这时T1再CAS操作A时是可行的。但实际上在T1第二次操作A时，已经被其他线程修改过了。）（引入`版本号`或`时间戳`解决）
> 2. 可能一次成功，一般用循环CAS，会导致饥饿问题
> 3. 只能操作一个变量

## JUC

### AQS

JUC的核心

AQS 的全称为（ AbstractQueuedSynchronizer ）：抽象的队列同步器  ，⽤来构建锁和同步器的框架  

​        有独占（一次只能一个线程获取。如ReentrantLock），共享资源两种状态。

   同步器的核心是AQS核心（volatile的变量state资源状态计数）

本身实现的是一些排队和阻塞的机制

![2](http://concurrent.redspider.group/article/02/imgs/AQS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png)

存储拥有线程的Node节点

Node可以实现两个队列：CLH线程同步双向队列；nextWaiter实现Condition条件上的等待线程队列（单向 主要在ReentrantLock）

AQLS ：state是long类型 与AQS 都继承 AOS（独占模式）

juc.lock包下有3个接口：Condition（object的wait/notify的加强版）、`Lock`、`ReadWriteLock



### 通信工具类

| 类             | 作用                                       | 备注                                                         |
| -------------- | ------------------------------------------ | ------------------------------------------------------------ |
| Semaphore      | 限制线程的数量                             | sync默认是非公平  acquire release                            |
| Exchanger      | 两个线程`交换数据`                         | 支持泛型、park/unpark阻塞等待                                |
| CountDownLatch | 线程等待直到计数器减为0时开始工作          | **计数值（count）实际上就是闭锁需要等待的线程数量** 只能设置一次 |
| CyclicBarrier  | 作用跟CountDownLatch类似，但是可以重复使用 | 内部使用Lock + Condition实现的等待/通知模式                  |
| Phaser         | 增强的CyclicBarrier                        | 控制线程数量                                                 |

### CountDownLatch

用来控制一个或者多个线程`等待多个线程`。

维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。

![img](复习笔记.assets/ba078291-791e-4378-b6d1-ece76c2f0b14.png)

### CyclicBarrier

循环屏障(可以reset()计数器)。用来控制`多个线程互相等待`，只有当多个线程都到达时，这些线程才会继续执行。

通过`维护计数器`来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。

![](复习笔记.assets/f71af66b-0d54-4399-a44b-f47b58321984.png)

### Semaphore

类似于操作系统中的信号量，可以控制对互斥资源的访问线程数

```Java
Semaphore semaphore = new Semaphore(ResCount);
semaphore.acquire();
//
semaphore.release();

```

### FutureTask

FutureTask 实现了 RunnableFuture 接口，RunnableFuture 接口继承自 Runnable 和 Future<V> 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。

可用于`异步获取执行结果`或`取消执行任务`的场景。

### BlockingQueue

- **FIFO 队列** ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）
- **优先级队列** ：PriorityBlockingQueue

提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。

### ForkJoin

Fork/Join框架是一个实现了ExecutorService接口的多线程处理器，它专为那些可以通过`递归分解成更细小的任务而设计，最大化的利用多核处理器来提高应用程序的性能。`

工作窃取算法：多线程执行不同任务队列的过程中，某个线程执行完自己队列的任务后从其他线程的任务队列里窃取任务来执行

双端队列

ForkJoinPool是用于执行ForkJoinTask任务的执行（线程）池。

![4](复习笔记.assets/join流程图.png "ForkJoinPool.join()")

## 线程池

使用线程池原因：

1. 复用已创建的线程
2. 控制并发的数量 。减少资源消耗（main）
3. 对线程统一管理

### ThreadPoolExecutor 

建议使用

> `Executor`接口的实现类：
>
> `prestartAllCoreThreads()` ：方法预热线程池，不断向线程池中加入新的worker线程，直到达到 核心线程数 corePoolSize
>
> 工作线程池 `workers`：使用 HashSet 用于存取 work 线程。
>
> 
>
> 4个构造方法：5 6 6 7 个参数
>
> 构造方法参数：
>
> - **int corePoolSize**：该线程池中**核心线程数最大值**
>
>   > 核心线程：线程池中有两类线程，核心线程和非核心线程。核心线程默认情况下会一直存在于线程池中，即使这个核心线程什么都不干（铁饭碗），而非核心线程如果长时间的闲置，就会被销毁（临时工）。
>
> - **int maximumPoolSize**：该线程池中**线程总数最大值** 。
>
>   > 该值等于核心线程数量 + 非核心线程数量。
>
> - **long keepAliveTime**：**非核心线程闲置超时时长**。
>
>   > 非核心线程如果处于闲置状态超过该值，就会被销毁。如果设置allowCoreThreadTimeOut(true)，则会也作用于核心线程。
>
> - **TimeUnit unit**：keepAliveTime的单位。
>
>   TimeUnit是一个枚举类型 ，包括以下属性：
>
> > NANOSECONDS ： 1微毫秒 = 1微秒 / 1000 MICROSECONDS ： 1微秒 = 1毫秒 / 1000 MILLISECONDS ： 1毫秒 = 1秒 /1000 SECONDS ： 秒 MINUTES ： 分 HOURS ： 小时 DAYS ： 天
>
> - **BlockingQueue workQueue**：阻塞队列，维护着**等待执行的Runnable任务对象**。
>
>   常用的几个阻塞队列（提供了线程安全的访问方式  生产者-消费者）：
>
>   1. **LinkedBlockingQueue**
>
>      链式阻塞队列，底层数据结构是链表，默认大小是`Integer.MAX_VALUE`，也可以指定大小。按先进先出排序
>
>   2. **ArrayBlockingQueue**
>
>      数组阻塞队列，`有界`，底层数据结构是数组，需要指定队列的大小。默认是非公平锁
>
>      自旋获得锁，判断队列是否已满-put or take
>
>   3. **SynchronousQueue**
>
>      同步队列，内部容量为0，每个put操作必须等待一个take操作，反之亦然。
>
>   4. **DelayQueue**
>
>      延迟队列，该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 
>
>   5. **PriorityBlockingQueue**
>
>      基于优先级的`无界`阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），内部控制线程同步的锁采用的是非公平锁。
>
> 非必需参数：
>
> - **ThreadFactory threadFactory** 
>
>   创建线程的工厂，用于批量创建线程，统一在创建线程时设置一些参数，如是否守护线程、线程的优先级等。如果不指定，会新建一个默认的线程工厂
>
> - **RejectedExecutionHandler handler**
>
>   拒绝处理策略，线程数量大于最大线程数就会采用拒绝处理策略
>
>   1. **ThreadPoolExecutor.AbortPolicy**：**默认拒绝处理策略**，丢弃任务并抛出RejectedExecutionException异常。
>   2. **ThreadPoolExecutor.DiscardPolicy**：丢弃新来的任务，但是不抛出异常。
>   3. **ThreadPoolExecutor.DiscardOldestPolicy**：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。
>   4. **ThreadPoolExecutor.CallerRunsPolicy**：由调用线程处理该任务。
>
> runState：
>
> 为RUNNING、SHUTDOWN、STOP、TIDYING 、TERMINATED。
>
> - 线程池创建后处于**RUNNING**状态。
>
> - 调用shutdown()方法后处于**SHUTDOWN**状态，线程池不能接受新的任务，清除一些空闲worker,会等待阻塞队列的任务完成。
>
> - 调用shutdownNow()方法后处于**STOP**状态，线程池不能接受新的任务，中断所有线程，阻塞队列中没有被执行的任务全部丢弃。此时，poolsize=0,阻塞队列的size也为0。
>
> - 当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为**TIDYING**状态。接着会执行terminated()函数。
>
>   > ThreadPoolExecutor中有一个控制状态的属性叫ctl，它是一个AtomicInteger类型的变量。
>
> - 线程池处在TIDYING状态时，**执行完terminated()方法之后**，就会由 **TIDYING -> TERMINATED**， 线程池被设置为TERMINATED状态。
>
> 线程池任务处理流程：
>
> ![3](复习笔记.assets/线程池主要的处理流程.png)
>
> 加入任务队列时 二次检查线程池状态
>
> ThreadPoolExecutor在创建线程时，会将线程封装成**工作线程worker**,并放入**工作线程组**中，然后这个worker反复从阻塞队列中拿任务去执行

不建议使用Executors  返回线程池对象

#### Executors 线程池种类

- newCachedThreadPool   无核心线程  60s 一个任务一个进程 可缓存
- newFixedThreadPool      无非核心线程 可以一直在阻塞队列  固定线程
- newSingleThreadPool  仅有1个核心线程
- newScheduledThreadPool   定长线程池，支持定时及周期性任务执行

## ConcurrentHashMap类

key、value不可以有null

JDK 1.7:

分段锁

`Segment数组结构和HashEntry数组`结构组成。Segment是一种可重入锁ReentrantLock，HashEntry则用于存储键值对数据。

JDK1.8:

Node 数组 + 链表 / 红⿊树。  

1. 链表会在长度达到8的时候转化为`红黑树`
2. 只以某个位置的`头结点`（链表的头结点或红黑树的root结点）为锁，配合`自旋+CAS`避免不必要的锁开销，进一步提升并发性能。

## CopyOnWrite 容器

写时复制，先写到副本中，在改引用

`CopyOnWriteArrayList`：`读写分离，安全`；吃内存、读操作没加锁会读到旧数据

有**数据一致性**的问题，它只能保证**最终数据一致性**

如晚上更新黑名单



# JVM：

HotSpot VM: 目前使用范围最广的Java虚拟机

JIT ：Just In Time,准时生产  及时编译技术 。 运行时 会`保存翻译过的机器码`，以备下次使用

### 内存模型

![2](复习笔记.assets/v2-4bdb0e583322be755ad6cb9bea34bb16_720w.jpg)

- 程序计数器：内存区域是唯一一个在《Java虚拟机规范》 中`没有规定任何OutOfMemoryError情况的区域`。  也没有GC  。线程私有

- 虚拟机栈：普遍认为的栈 ；线程私有，也没有GC；存储 `局部变量表`、`操作数栈`、`常量池引用`等。  栈帧。为执行Java方法服务
- 本地方法栈： 为 native方法 服务 。线程私有

> 出错：
>
> - OOM:内存溢出错误。申请内存时，无法申请到足够的内存
>
> - SOF：StackOverflow（堆栈溢出）
>
>   ​    当应用程序递归太深（请`求栈深度超过允许深度`）而发生堆栈溢出时，抛出该错误：

- 堆：`对象的分配与回收`.是Java虚拟机中最大的一块内存，是线程共享的内存区域，基本上所有的对象实例以及数组都是在堆上分配空间。堆区细分为Yound区年轻代和Old区老年代(比例是 1:2)，其中年轻代又分为Eden、S0、S1 3个部分，他们默认的比例是`8:1:1`的大小。堆不需要连续内存，并且可以动态增加其内存。 `字符串常量池在 堆中`

  Xms:初始大小   Xmx：最大

  堆的动态年龄：Hotspot遍历所有对象时，按照年龄`从⼩到⼤`对其所占⽤的⼤⼩进⾏`累积`，当累积的某个年龄⼤⼩`超过了survivor区的⼀半时`，取这个年龄和MaxTenuringThreshold中更⼩的⼀个值，作为新的晋升年龄阈值”。  

  分配策略：

  - 对象在新⽣代中 eden 区分配  ，若不够了，则进行Minor GC；（分配担保机制）

  - 大对象直接进入老年代；

  - ⻓期存活的对象将进⼊⽼年代  

- 方法区

  用于存放`已被加载`的`类信息、常量、静态变量`、`即时编译器编译后的代码`等数据。各个`线程共享`的内存区域  。  回收主要：对常量池的回收和对类的卸载。

  永久代(与堆连续)和元空间(内存)都是方法区的实现方式，方法区是jvm规范，一种抽象概念。

  不使用永久代的原因：导致了Java应用更容易遇到`内存溢出`的问题（永久代有-XX： MaxPermSize的上限  

  jdk1.8后元空间用的是`直接内存`，不是java堆内存，`存储类的元信息`，`静态变量和常量池放入堆中`。`因此不存在OOM的情况`，之前的永久代是JVM管的，因此会出现OOM，而且很难优化很难排查。

- 运行时常量池：方法区的一部分，class文件被加载进了内存之后，运行时常量池保存在了方法区中。

  > 静态常量池:存在于class文件中，比如经常使用的javap -verbose中
  >
  > 
  >
  > 编译器生成的字面量和符号引用
  >
  > 除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。

- 直接内存

### 堆外内存

把内存对象 分配在 Java虚拟机的 堆以外的内存，直接受操作系统管理，在一定程度上减少垃圾回收对应用程序造成的影响。

java.nio.DirectByteBuffer 对象 进行堆外内存的管理和使用

优点：

- 减少垃圾回收
- 加快复制的速度

缺点：缺少jvm控制，内存溢出排查困难



### NIO

NIO(New Input/Output)  ：

引入了一种基于通道与缓存区的I/O方式

3大核心组件： buffer、channel、selector

### GC分类：

> 1.部分收集 (Partial GC)：
>
> - 新⽣代收集（Minor GC / Young GC）：只对新⽣代进⾏垃圾收集；`采用标记复制`，使用标记-清除效率低。
>- ⽼年代收集（Major GC / Old GC）：只对⽼年代进⾏垃圾收集。需要注意的是 Major GC 在
>   有的语境中也⽤于指代整堆收集；   `标记清除`  或   `标记整理`
> - 混合收集（Mixed GC）：对整个新⽣代和部分⽼年代进⾏垃圾收集。
> 
> 2.整堆收集 (Full GC)：收集整个 Java 堆和⽅法区。  
>
> 
>
> system.gc函数会不会马上进行垃圾回收？
>
> 不会，只是建议Java虚拟机对此部分内存进行回收，但是不一定会发生GC
>
> 
>
> 什么时候触发YGC和FGC？：
>
> ​	当一个新的对象来申请内存空间的时候，`如果Eden区无法满足内存分配需求，则触发YGC，使用中的Survivor区和Eden区存活对象送到未使用的Survivor区`
>
> 如果YGC之后还是没有足够空间，则直接进入`老年代分配`，`如果老年代也无法分配空间，触发FGC`，FGC之后还是放不下则报出OOM异常。
>
> 频繁FullGC怎么排查？
>
> 1.可能内存分配不合理，比如Eden区太小，导致对象频繁进入老年代
>
> 2.内存泄漏
>
> jstat -gcutil  查看gc  `log日志`



### 对象的创建过程：

> 1.类加载检查 ？ 
>
> 未加载，执行类加载机制：
>
> 1. 加载：字节码加载成二进制流
>2. 验证 ：校验Class文件是否符合虚拟机规范（参数检验）
> 3.  准备 ：为静态变量、常量赋默认值
> 4.  解析 ： 把常量池中符号引用(以符号描述引用的目标)替换为直接引用(指向目标的指针或者句柄等)
> 5. 初始化：执行static代码块(cinit)进行初始化，如果存在父类，先对父类进行初始化
> 
> 2.分配内存（已加载）
>
> -  指针碰撞：内存规整
>-  空闲列表：不规整
> 3. 初始化默认值
> 4. 设置对象头
> 5. 执行init方法

对象的访问定位：1.使用句柄 2.直接指针

### 判断对象是否死亡：

1.引用计数法（减为0时） 2.可达性分析算法. （以GC ROOT为起点，从起点开始向下开始搜索，搜索走过的路径称为引用链，当一个对象到GC ROOT没有任何引用链相连的话(或者该对象不是GC Root对象时)，则对象可以判定是可以被回收的。）

可以作为GC ROOT对象：

+ 栈中引用的对象
+ 静态变量、常量 引用的对象
+ 本地方法栈native方法引用的对象

## 垃圾收集算法：

> 1.标记-清除：标记不可回收的 
> 
>2.复制：将不可回收的移动  新的一块
> 
>3.标记-整理：不可回收的移动到一侧
> 
>4.分代收集：新生代：复制   老年代：标记-清除 或  标记-整理

## 垃圾收集器：

> ![1](复习笔记.assets/v2-c91a192ed968ddb4405a73302c4977f7_720w.jpg)
>
> - Serial（单线程）收集器：工作时必须暂停所有其他所有工作线程(STW：stop-the-world)。（安全点 VM Threads专门处理特殊操作）新生代：复制  老年代：标记-整理
>
> - `ParNew收集器：`Serial收集器的多线程版本
>
> - Parallel Scavenge 收集器  ：关注吞吐量
>
> - Serial Old 收集器  ：Serial收集器的老年代版本
>
> - Parallel Old 收集器  ：Parallel Scavenge 收集器的老年代版本
>
> - `CMS收集器`：标记-清除  算法
>
>   - 初始标记
>
>   - 并发标记
>
>   - 重新标记
>
>   - 并发清除
>
> - `G1 （Garbage-First  ）收集器`  ：面向服务器。jdk9的默认垃圾回收器。`且不再区分年轻代和老年代回收`    `分区`
>
>   安全点：方法调用、循环跳转
>   
>   > 把内存划分为多个Region，每个Region的大小可以通过-XX：G1HeapRegionSize设置，大小为1~32M，对于大对象的存储则衍生出Humongous的概念，超过Re gion大小一半的对象会被认为是大对象，而超过整个Region大小的对象被认为是超级大对象，将会被存储在连续的N个Humongous Region中，G1在进行回收的时候会在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间优先回收收益最大的Region。
>  >
>   > 1. 初始标记：标记GC ROOT能关联到的对象，需要STW
>   > 2. 并发标记：从GCRoots的直接关联对象开始遍历整个对象图的过程，扫描完成后还会重新处理并发标记过程中产生变动的对象
>   > 3. 最终标记：短暂暂停用户线程，再处理一次，需要STW
>   > 4. 筛选回收：更新Region的统计数据，对每个Region的回收价值和成本排序，根据用户设置的停顿时间制定回收计划。再把需要回收的Region中存活对象复制到空的Region，同时清理旧的Region。需要STW
>
> - ZGC 收集器  ：标记-复制算法  

## 类加载器

![image-20210310213253067](复习笔记.assets/image-20210310213253067.png)

​	双亲委派模型要求除了顶层的启动类加载器外， `其余的类加载器都应有自己的父类加载器`。 类加载器之间的父子关系通常使用组合（Composition） 关系来复用父加载器的代码。  

​	如果一个类加载器收到了类加载的请求， 它首先不会自己去尝试加载这个类， 而是把这个请求委派给父类加载器去完成  。 如果都找不到   抛出`ClassNotFoundException`

目的：`防止重复加载同名的`，`防止破坏java核心的api`

（`为了能够回调代码`）打破：1.线程上下文类加载器（Thread Context ClassLoader） 。 这个类加载器可以通过java.lang.Thread类的setContext-ClassLoader()方法进行设置， 如果创建线程时还未设置， 它将会从父线程中继承一个， 如果在应用程序的全局范围内都没有设置过的话， 那这个类加载器默认就是应用程序类加载器。  

2. 自定义类加载器:重写loadClass方法

## 性能调优、工具

对应进程的JVM状态以定位问题和解决问题并作出相应的优化

**常用命令：**jps、jinfo、jstat、jstack、jmap

**jps：查看java`进程`及相关信息**

```java
jps -l 输出jar包路径，类全名
jps -m 输出main参数
jps -v 输出JVM参数
```

**jinfo：查看JVM参数**

```java
jinfo 11666
jinfo -flags 11666
```

**jstat：查看JVM运行时的`状态信息`，包括内存状态、垃圾回收**

```java
命令格式：
jstat [option] LVMID [interval] [count]
其中LVMID是进程id，interval是打印间隔时间（毫秒），count是打印次数（默认一直打印）

option参数解释：
-class class loader的行为统计
-compiler HotSpt JIT编译器行为统计
-gc 垃圾回收堆的行为统计
-gccapacity 各个垃圾回收代容量(young,old,perm)和他们相应的空间统计
-gcutil 垃圾回收统计概述
-gccause 垃圾收集统计概述（同-gcutil），附加最近两次垃圾回收事件的原因
-gcnew 新生代行为统计
-gcnewcapacity 新生代与其相应的内存空间的统计
-gcold 年老代和永生代行为统计
-gcoldcapacity 年老代行为统计
-gcpermcapacity 永生代行为统计
-printcompilation HotSpot编译方法统计
```

**jstack：查看JVM`线程快照`，jstack命令可以定位线程出现长时间卡顿的原因，例如死锁，死循环**

```java
命令格式：
jstack [-l] <pid> (连接运行中的进程)
jstack -F [-m] [-l] <pid> (连接挂起的进程)
jstack [-m] [-l] <executable> <core> (连接core文件)
jstack [-m] [-l] [server_id@]<remote server IP or hostname> (连接远程debug服务器)

option参数解释：
-F 当使用jstack <pid>无响应时，强制输出线程堆栈。
-m 同时输出java和本地堆栈(混合模式)
-l 额外显示锁信息
```

**jmap：可以用来查看内存信息**

```java
命令格式：
jmap [option] <pid> (连接正在执行的进程)
jmap [option] <executable <core> (连接一个core文件)
jmap [option] [server_id@]<remote server IP or hostname> (链接远程服务器)

option参数解释：
<none> to print same info as Solaris pmap
-heap 打印java heap摘要
-histo[:live] 打印堆中的 java对象统计信息
-clstats 打印类加载器统计信息
-finalizerinfo 打印在f-queue中等待执行finalizer方法的对象
-dump:<dump-options> 生成java堆的dump文件
　　　　　　dump-options:
　　　　　　live 只转储存活的对象，如果没有指定则转储所有对象
　　　　　　format=b 二进制格式
　　　　　　file=<file> 转储文件到 <file>
-F 强制选项
```





# :card_file_box:  数据库

## 关系型数据库 vs  NOSQL

关系型： 固定的表结构、不容易拓展； 支持事务和复杂查询

nosql：存储机制多样：键值对、基于图； 

## 三大范式

1. 列具有`原子性`，不可再分解   无重复的列
2. `每一非主属性完全函数依赖于候选键` （不存在非主属性对候选键的部分依赖）
3. 表中不包含已在其它表中定义的非主键字段。（`没有传递函数依赖`）

##  数据库开发规范

### 基础规范

（1）必须使用InnoDB存储引擎解读：支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高

（2）必须使用UTF8字符集解读：万国码，无需转码，无乱码风险，节省空间

（3）数据表、数据字段必须加入中文注释解读：N年后谁知道这个r1,r2,r3字段是干嘛的

（4）禁止使用存储过程、视图、触发器、Event解读：高并发大数据的互联网业务，架构设计思路是“解放数据库CPU，将计算转移到服务层”，并发量大的情况下，这些功能很可能将数据库拖死，业务逻辑放到服务层具备更好的扩展性，能够轻易实现“增机器就加性能”。数据库擅长存储与索引，CPU计算还是上移吧

（5）禁止存储大文件或者大照片解读：为何要让数据库做它不擅长的事情？大文件和照片存储在文件系统，数据库里存URI多好

### 命名规范

（6）只允许使用内网域名，而不是ip连接数据库

（7）线上环境、开发环境、测试环境数据库内网域名遵循命名规范业务名称：xxx线上环境：my10000m.mysql.jddb.com开发环境：yf10000m.mysql.jddb.com测试环境：test10000m.mysql.jddb.com从库在名称后加-s标识，备库在名称后加-ss标识线上从库：my10000sa.mysql.jddb.com

（8）库名、表名、字段名：小写，下划线风格，不超过32个字符，必须见名知意，禁止拼音英文混用

（9）表名t_xxx，非唯一索引名idx_xxx，唯一索引名uniq_xxx

（10）单实例表数目必须小于500

（11）单表列数目必须小于30

（12）表必须有主键，例如自增主键解读：

a）主键递增，数据行写入可以提高插入性能，可以避免page分裂，减少表碎片提升空间和内存的使用

b）主键要选择较短的数据类型， Innodb引擎普通索引都会保存主键的值，较短的数据类型可以有效的减少索引的磁盘空间，提高索引的缓存效率

c） 无主键的表删除，在row模式的主从架构，会导致备库夯住

（13）禁止使用外键，如果有外键完整性约束，需要应用程序控制解读：外键会导致表与表之间耦合，update与delete操作都会涉及相关联的表，十分影响sql 的性能，甚至会造成死锁。高并发情况下容易造成数据库性能，大数据高并发业务场景数据库使用以性能优先

### 字段设计规范

（14）必须把字段定义为NOT NULL并且提供默认值解读：

```
a）``null``的列使索引/索引统计/值比较都更加复杂，对MySQL来说更难优化` `b）``null` `这种类型MySQL内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条件下，表中有较多空字段的时候，数据库的处理性能会降低很多` `c）``null``值需要更多的存储空，无论是表还是索引中每行中的``null``的列都需要额外的空间来标识` `d）对``null` `的处理时候，只能采用is ``null``或is not ``null``，而不能采用=、in、、!=、not in这些操作符号。如：where name!=’shenjian’，如果存在name为``null``值的记录，查询结果就不会包含name为``null``值的记录
```

（15）禁止使用TEXT、BLOB类型解读：会浪费更多的磁盘和内存空间，非必要的大量的大字段查询会淘汰掉热数据，导致内存命中率急剧降低，影响数据库性能

（16）禁止使用小数存储货币解读，小数容易导致钱对不上

（17）必须使用varchar(20)存储手机号解读：

```
a）涉及到区号或者国家代号，可能出现+-()` `b）手机号会去做数***算么？` `c）varchar可以支持模糊查询，例如：like“``138``%”
```

禁止使用ENUM，可使用TINYINT（很小的整数。带符号的范围是-128到127。无符号的范围是0到255。）代替解读：

​	a）增加新的ENUM值要做DDL操作

​	 b）ENUM的内部实际存储就是整数，你以为自己定义的是字符串？

（19）单表索引建议控制在`5个`以内

（20）单索引字段数不允许超过5个解读：字段超过5个时，实际已经起不到有效过滤数据的作用了

（21）禁止在更新十分频繁、区分度不高的属性上建立索引解读：a）更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能b）“性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似

（22）建立组合索引，必须把区分度高的字段放在前面解读：能够更加有效的过滤数据

（23）**禁止使用SELECT \*，只获取必要的字段，需要显示说明列属性解读：**

```
a）读取不需要的列会增加CPU、IO、NET消耗**` `b）不能有效的利用覆盖索引**` `c）使用SELECT *容易在增加或者删除字段后出现程序BUG**
```

（24）禁止使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性解读：容易在增加或者删除字段后出现程序BUG

（25）禁止使用属性隐式转换解读：SELECT uid FROM t_user WHERE phone=13800000000 会导致全表扫描，而不能命中phone索引，猜猜为什么？（这个线上问题不止出现过一次）

（26）禁止在WHERE条件的属性上使用函数或者表达式解读：SELECT uid FROM t_user WHERE from_unixtime(day)>='2017-01-15' 会导致全表扫描正确的写法是：SELECT uid FROM t_user WHERE day>= unix_timestamp('2017-01-15 00:00:00')

（27）禁止负向查询，以及%开头的模糊查询解读：

```
a）负向查询条件：NOT、!=、、!、NOT IN、NOT LIKE等，会导致全表扫描` `b）%开头的模糊查询，会导致全表扫描
```

（28）禁止使用JOIN查询，禁止大表使用子查询解读：会产生临时表，消耗较多内存与CPU，极大影响数据库性能

（29）禁止使用OR条件，必须改为IN查询解读：旧版本Mysql的OR查询是不能命中索引的，即使能命中索引，为何要让数据库耗费更多的CPU帮助实施查询优化呢？

（30）应用程序必须捕获SQL异常，并有相应处理

（31）同表的增删字段、索引合并一条DDL语句执行，提高执行效率，减少与数据库的交互。



## SQL语句

```sql
// 查询出各班级的前三名
//  只要班级里有三个学生的分数超过这个学生，那么这个学生就不是前三名。
select * from student b  where  not EXISTS(select * from student c where c.classId=b.classId and b.grade < c.grade GROUP BY c.classId HAVING COUNT(*)>3 )

insert into t1(f1,f2) values(v1,v2);
insert into t1 values(v1,v2);


DESC： 降序排序  asc 升序
limit 1 ： 只要1个   limit 2,1  只要第三个 结果的索引值（默认是 0），返回的数量   

WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。
WHERE语句在GROUP BY语句之前；SQL会在分组之前计算WHERE语句。   
HAVING语句在GROUP BY语句之后；SQL会在分组之后计算HAVING语句。
```

### 语法

通配符：

- **%** 匹配 >=0 个任意字符；
- **_** 匹配 ==1 个任意字符；
- **[ ]** 可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。

使用 Like 来进行通配符匹配。

```sql
SELECT *
FROM mytable
WHERE col LIKE '[^AB]%'; -- 不以 A 和 B 开头的任意文本
```

连接 效率一般比子查询快

内连接（等值连接）-自连接(表自身) - 自然连接（自动连接同名列） - 外连接（保留了没有关联的那些行） 

保留失配的元祖：左外连接：以左表为主表，右表没数据为null；

### SQL注入

通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令

永远不要信任用户的输入，我们必须认定用户输入的数据都是不安全的，我们都需要对用户输入的数据进行过滤处理

### SQL优化

避免全表扫描

在 where 及 order by 涉及的列上建立索引

避免在where子句中进行 null值判断、！= 或 <>操作符 、or 连接（使用 union all）、in 和not in、like ‘%abc% ’ 

# MYSQL

默认端口号：3306

- 关系型数据库： 容易理解，关系模型组织。  支持复杂查询
- 非关系型数据库：不需要经过SQL层的解析，基于键值对，多种存储类型

### 一条语句执行过程

连接器 用户名密码   —— TCP连接  ——查出权限——词法、语法分析、优化器（决定使用哪个索引）、执行器（判断权限）

##  InnoDB  ：

支持行级锁（粒度最小）、  `事务`和崩溃后的安全恢复（redo log ）、  支持外键 MVCC 、  `数据文件本身就是索引文件`，支持`在线热备份、`外键

数据库并发控制: 分别是`乐观锁`和`悲观锁`以及`时间戳`。

### mvcc

> 多版本控制，只有写写之间相互阻塞，其他三种操作都可以并行。 
>
> 每行数据都存在一个版本，每次数据更新时都更新该版本。 事务以`排他锁`的形式修改原始数据。修改时	Copy出当前版本, 然后随意修改，各个事务之间无干扰保存时比较版本号，如果成功(commit)，则覆盖原记录, 失败则放弃copy(rollback)
>
> 通过undo log可以找回数据的历史版本。（当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取）找回的数据历史版本可以提供给用户读(按照隔离级别的定义，有些读请求只能看到比较老的数据版本)，也可以在回滚的时候覆盖数据页上的数据。在InnoDB内部中，会记录一个全局的活跃读写事务数组，其主要用来判断事务的可见性。
>
> 在InnoDB当中，要对一条数据进行处理，会先看`这条数据的版本号是否大于自身事务版本`（非RU隔离级别下当前事务发生之后的事务对当前事务来说是不可见的），如果大于，则从历史快照（undo log链）中获取旧版本数据，来保证数据一致性。
>
> - 通过保存数据在某个时间点的快照来实现的
>
> - 应对高并发事务, MVCC比`单纯的加锁`更高效
>
> - MVCC只在 `READ COMMITTED` 和 `REPEATABLE READ` 两个隔离级别下工作;
>
> - MVCC可以使用 `乐观(optimistic)锁` 和 `悲观(pessimistic)锁`来实现;
>
> - InnoDB存储引擎在数据库每行数据的后面添加了**三个字段**, 不是两个!!（事务ID、滚动指针、行ID）
>
>   （当由innodb自动产生聚集索引时，聚集索引包括这个DB_ROW_ID的值，否则聚集索引中不包括这个值，这个用于索引当中。）
>
> - 各数据库中MVCC实现并不统一

## join原理：

> 嵌套索引实现方式: 1.简单   2.索引嵌套   3.无索引，先将于join列有关的放入缓冲池中

## 字符集

字符集指的是⼀种从⼆进制编码到某类字符符号的映射。

校对规则则是指某种字符集下的排序规则。 MySQL中每⼀种字符集都会对应⼀系列的校对规则  （类似继承 库中的表-库）

## 慢查询

全名是`慢查询日志`，是MySQL提供的一种日志记录，运行时间超过long_query_time值的SQL语句，则会被记录到慢查询日志

查看慢查询日志，具体SQL看执行计划

## 索引

索引也是一张表，该表保存了`主键与索引字段`（数据量小），并指向实体表的记录，数据库表创建  提高查询速度  对表进行加锁操作          

### 为什么使用索引

- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
- `可以大大加快数据的检索速度`，这也是创建索引的最主要的原因。
- 帮助服务器避免排序和分组、临时表
- 将随机IO变为顺序IO。
- 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

常见的索引包括：主键索引、唯一索引(可为null，插入时要判断是否重复)、普通索引、全文索引（使用倒排索引使用）

根据数据结构来划分：

- 主要有  `BTree索引`（B树中的B+Tree  ）和 `哈希索引`  （单条记录查询，O(1) 时间进行查找，但是失去了有序性  ）

  > - b树:m阶  多路平衡查找树  
  >
  >   根节点最少可以只有1个关键字。
  >
  >   非根节点至少有m/2个关键字。
  >
  >   每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。
  >
  >   插入规则：**判断当前结点key的个数是否小于等于m-1，如果满足，直接插入即可，如果不满足，将节点的中间的key将这个节点分为左右两部分，中间的节点放到父节点中即可。**
  >
  >   删除规则：1.若删除叶子节点，如果删除之后，节点数还 > m/2,直接删除；
  >
  >   ​              -  小于则向兄弟节点借元素，若兄弟节点 >(m/2) 则**先将父节点的元素移到该节点，然后将兄弟   			节点的元素再移动到父节点**。
  >
  >   ​           -  若兄弟节点也不够，**先将父节点的元素移到该节点，然后，将当前节点及它的兄弟节点中的key                 			合并，形成一个新的节点**。
  >
  >   ​           2.  **对于非叶子节点的删除，我们需要用后继key（元素）覆盖要删除的key，然后在后继key所在的子支中删除该后继key**。
  >
  > - 有n棵子树的非叶子结点中含有n个关键字（b树是n-1个），这些关键字不保存数据，只用来索引，所有数据都保存在叶子节点（b树是每个关键字都保存数据）。
  >     所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
  >     所有的非叶子结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。通常在b+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。
  >     同一个数字会在不同节点中重复出现，根节点的最大元素就是b+树的最大元素。
  >     
  >     ![image-20210412104141538](复习笔记.assets/image-20210412104141538.png)
  >     
  >     若Leaf Page已经满了，但是其他左右兄弟节点没满：先进行旋转操作
>
>     删除操作：按照 `填充因子`来控制
>
>     单一节点存储元素更多，`io性能高，查找稳定`。
>
>     为什么不使用b树：`只用加载非叶子节点，占用内存少`。（非叶子节点保存的指针数量变少，要想保存大数据，要增加高度，IO变多）    只遍历叶子节点就可以遍历全树，而b树要中序遍历
>
>     一棵B+树大约可以存放2千万 行数据，一个叶子节点大小为“一页”，16k
>
>     b+树叶子`节点由链表链接`，所以select*操作，只需要找到第一个节点就行，不用再回溯

  

> - 聚簇索引（聚集索引、主键索引）：  逻辑上连续（页通过双向链表链接）
>
> ​      `每张表只能有1个`  按照表的`主键`构造，数据也是索引的一部分
>
> ​	在根据主索引（聚簇索引）搜索时，直接找到key所在的节点即可取出数据；
>
> ​	 -  优点：相关数据保存在一起、数据访问更快
>
> ​	- 缺点：更新代价高、插入速度慢、可能导致页分裂、全表扫描变慢
>
> - 辅助索引：其余的索引，data域存储相应记录`主键的值`而不是地址（书签就是数据的聚集索引键） 即 键值+聚集索引键
>
> ​	在根据`辅助索引`查找时，则需要先取出主键的值，再⾛⼀遍主索引。 因此，在设计表的时候，不建议使⽤过⻓的字段作为主键，也不建议使⽤⾮单调的字段作为主键，这样会造成主索引频繁分裂  。
>
> - 非聚簇索引： 主索引结构与辅助索引的一致，都是存储的指向键值的`物理地址`（只是主索引不允许空值及重复值）
>
> `Innodb`使用`自增id`作为主键
>
> 主键为什么自增：维护索引方便，直接往后插入，不用在中间插（索引会分裂、影响效率）
>
> 索引分裂：可以决定向左、向右分裂和分裂点是哪个
>
> ```sql
> //   唯一索引：列值的必须唯一，但允许有空值。
> CREATE UNIQUE INDEX indexName ON mytable(username(length)) 
> ```
>
> ```sql
> 1. ALTER TABLE students  ADD UNIQUE INDEX uni_name (name);
> 2. CREATE/DROP iNDEX index_name on student(index_col_name,);
> 3CREATE TABLE mytable(  ID INT NOT NULL, username VARCHAR(16) NOT NULL,  
>  INDEX [indexName] (username(length))  );   //创建时直接指定
> 
> ```
> 用户可以设置对整个列的数据进行索引，也可以只索引一个列的开头部分数据
>
> ```sql
> // 只索引b的前100个字段
> ALTER TABLE students ADD KEY idx_b(b(100));
> 
> 
> //展示索引
> SHOW INDEX FROM students；
> 
> 
> //更新表信息 如Cardinality 唯一值的数目（估计）  尽可能接近1
> ANALYZE TABLE
> 
> ```
>
> FIC 快速索引创建
>
>  针对辅助索引，创建时表加一个S锁
>
> 前缀索引：对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。前缀长度的选取需要根据索引选择性来确定。
>
> Online DDL：除允许辅助索引创建，支持DML操作（写入到一个缓存中）  
>
> 索引失效的情况（不满足最左前缀原则、where 后面不能用函数）
>
> ​          最左前缀匹配原则：MySQL会一直向右匹配直到遇到范围查询（>    、<、between 、 like ）就停止匹配。
>
> ​                                                                     = 和 in 可以乱序
>
> 索引使用：高选择性、很少一部分数据使用B+树索引
>
> - 联合索引：对表上的多个列进行索引  （a，c） 有序  在第一个字段有序的基础再对后面字段排序
>
> - 覆盖索引：索引包含（或者说覆盖）所有需要查询的字段的值，不用在做回表操作。从辅助索引中就可以得到查询的记录，减少IO操作；统计问题 
>
>      解释：如果不是主键索引，叶子节点存储的是`主键+列值`。最终还是要“回表”，也就是要通过主键再查找一次,这样就 会比较慢。覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！
>
> 
>
> 
>
>  全文检索：将存储于数据库中的整本书或文章中的`任意内容信息查找出来`的技术
>
> ​                    表中有两列：word字段、ilist字段（DocumentId,Position）
>
> ​                    FTS Index Cache(全文检索索引缓存) 红黑树实现
>
> -  倒排索引：全文检索的实现方式。在辅助表存储 单词位置的映射
>    -  使用 关联数组实现
>       -  inverted file index {单词，单词所在文档的ID}
>       -  full inverted index{单词，(单词所在文档的ID,在具体文档中的位置}
>
> `自适应索引`：当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。
>
> MySQL 5.6引入了索引下推优化





## explain

>  `模拟Mysql优化器是如何执行SQL查询语句`的，从而知道Mysql是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。 可以帮助我们分析 select 语句，让我们知道查询效率低下的原因，从而`改进`我们的查询。
>
>  具体关注：  
>
>  - type   ： ALL：全表扫描    index：索引优化查询     range：有范围的索引扫描   ref：使用索引但不       为主键      和unique     ref_eq: 主键或唯一索引  const：将主键放置到where后面作为条件查询
>  - key：具体使用的索引名
>  - rows：扫描的行数
>  - extra：
>
>  



## 事务


- `事务`是逻辑上的⼀组操作，要么都执⾏，要么都不执⾏  

  - 原⼦性（Atomicity） undo log 回滚日志
  - ⼀致性（Consistency）  
  - 隔离性（Isolation）   锁、MVCC
  -  持久性（Durability）  redo log 重做日志

  保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。
  
  > WAL : Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。
  >
  > 重做日志：`内存中的重做日志缓冲`、`重做日志文件`
  >
  > - redo log：重做日志,记录数据变成了什么，保证事务的原子性和持久性（恢复提交事务修改的页操作）物理日志，InnoDB 存储引擎层的日志（快）、顺序读写。循环写，可以用于异常故障宕机恢复数据。
  >
  > - undo log: 事务的一致性（回滚行记录到某个特定版本及MVCC）逻辑日志 （根据每行记录进行记录）、会随机读写。undo也会产生redo     1个rollback段有1024 undo log 段，分配undo log 页
  >
  > fsync操作将日志缓冲写入日志文件
  >
  > - binlog：归档日志,逻辑日志，Server 层,以二进制的形式记录的是这个语句的原始逻辑，依靠 binlog 是没有 crash-safe 能力的，可以用于主从复制
  >
  >   binlog 有两种模式，statement 格式的话是记 sql 语句;  
  >
  >   ​                                   row 格式会记录行的内容，记两条，更新前和更新后都有。



```
BEGIN:

COMMIT;

END;
```



## 并发带来的问题：

> - 脏读（Dirty read） : 当⼀个事务正在访问数据并且对数据进⾏了修改，⽽这种修改还没有提
>  交到数据库中，这时另外⼀个事务也访问了这个数据，然后使⽤了这个数据。因为这个数据
>   是`还没有提交的数据`，那么另外⼀个事务读到的这个数据是“脏数据”，依据“脏数据”所做的
>   操作可能是不正确的。
> - 丢失修改（Lost to modify） : `指在⼀个事务读取⼀个数据时，另外⼀个事务也访问了该数`
>   `据`，那么在第⼀个事务中修改了这个数据后，第⼆个事务也修改了这个数据。这样第⼀个事
>   务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事
>   务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被
> - 不可重复读（Unrepeatableread） : 指在⼀个事务内`多次`读同⼀数据。在这个事务还没有结
>   束时，另⼀个事务也访问该数据。那么，在第⼀个事务中的两次读数据之间，由于第⼆个事
>   务的`修改`导致第⼀个事务两次读取的`数据`可能不太⼀样。这就发⽣了在⼀个事务内两次读到
>   的数据是不⼀样的情况，因此称为不可重复读。
> - 幻读（Phantom read） : 幻读与不可重复读类似。它发⽣在⼀个事务（T1）读取了⼏⾏数
>   据，接着另⼀个并发事务（T2）插⼊了⼀些数据时。在随后的查询中，第⼀个事务（T1）（`连续执行了两次，得到结果不一样`）就会发现`多了`⼀些原本不存在的`记录`，就好像发⽣了幻觉⼀样，所以称为幻读。  
>
> 不可重复读：update操作   ，行锁避免
>
> 幻读：insert、delete操作  ，表锁避免

快照：一致性视图   

> 隔离级别                                                          脏读             不可重复读              幻读     底层原理
> READ-UNCOMMITTED(读取未提交)              √                        √                           √          不加锁
> READ-COMMITTED （读取已提交）             ×                         √                           √
> REPEATABLE-READ（`可重复读`）              ×                         ×                           √          快照读：MVCC 当前读：间隙锁
> SERIALIZABLE    （可串行化）                      ×                         ×                          ×            顺序执行，读共享锁，写排它锁

每个 select 语句都有自己的一份快照，而不是一个事务一份，所以在不同的时刻，查询出来的数据可能是不一致的。

可重复读：事务开始的时候生成一个当前事务全局性的快照

读已提交：每次执行语句的时候都重新生成一次快照。



加锁的过程要分有索引和无索引两种情况：

- 有索引： 直接锁住 这行数据
- 无索引：无法直接定位到当前行，所以先 对所有行 加锁，然后筛选过滤释放掉不符合条件的行



## 锁：

- latch：轻量级锁 分为mutex，rwlock
- lock：对象是事务，    共享锁  排他锁

类型：共享锁（s 读锁) 、排他锁（X 写锁）   （意向锁：层次）  都是当前读：当前操作的是最新记录

​          一致性非锁定读、一致性锁定读、自增长与锁、外键与锁

### 锁算法：

InnoDB存储引擎的`锁算法`有三种：

- Record lock：记录锁，单个⾏记录上的锁（含有唯一属性）只锁住索引本身

- Gap lock：间隙锁，锁定⼀个范围，不包括记录本身

- Next-key lock： `record+gap 锁定⼀个范围，包含记录本身（对于行查询使用 解决幻读）`

  不仅锁住扫描到的索引，而且还锁住这些索引覆盖的范围

InnoDB的默认隔离：可重复读，  使用锁算法 next-key 解决 幻读

表象：快照读（不加锁的非阻塞读  select）

- 记录中存储的隐藏列DB_TRX_ID、DB_ROW_ID、DB_ROLL_ID
- undo日志根据上述隐藏列来进行记录数据回滚（版本回滚）
- review机制

底层： next-key（行锁+Gap锁）

## 数据类型：

> char定长 varchar可变长 nchar存储汉字（都是2个字节） nvarchar



Statement
 ├——-PreparedStatement(预编译)
 ├——-├——- CallableStatement
    

## 场景优化

某个表，增删改查以及查询请求都很多，优化：

先看慢查询、再看explain 根据执行计划去优化（分表、库 分布式）

## 分库、分表

目的：提升性能（查询QPS过高时）、增加可用性。

![1](https://ucc.alicdn.com/pic/developer-ecology/9de9d1a69aed42dc952b248521910fab.png)

为`技术`服务

分库：

读写分离：

   问题：主从同步延迟  解决：1.强制将读请求路由到主库处理 例：sharing-JDBC  2.延迟读取

切分方式： 水平、垂直

分表：数据达到千万级别



数据均匀散列：

基于一致性Hash算法 裁剪。按照buyerId切分，把Hash环的数量降低到4096个  索引算法不同



主键ID的唯一性问题：让所有的分库使用的`ID段按照等差数列进行分隔`，每次ID段用完之后，再按照固定的步长比递增

第X库、第Y次分配的ID段起始索引就是：   X * 步长 + (Y-1) * (库数量 * 步长)




分库分表查询：

对于基于shardingkey（分表的字段）的查询,唯一主键，（分布式生成唯一ID算法：雪花算法等）

对于非shardingkey的查询可以通过双份数据和数仓、ES的方案来解决



# Redis

C语言开发的内存数据库，可以做`缓存`，`分布式锁`甚至是`消息队列`

快的原因：

- 完全基于内存操作
- C语言实现，优化过的数据结构
- 使用单线程，无上下文的切换成本
- 基于非阻塞的IO多路复用机制

之前是 Memcached 

优点：

- `支持更丰富的数据类型`

-  数据的持久化（可以保存在磁盘中，读取：1.`快照`（snapshotting， RDB 保存数据库状态  全量持久化 save(同步)和bgsave(异步)  以`二进制`文件，是在某个时间 点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复  ）默认开启 

   2.只追加⽂件（append-only file, 日志文件，AOF 保存redis服务器所执行的写命令：追加、写入、同步） 增量持久化  ）   默认关闭
   
   
   
    高性能、高并发

## 数据类型：

- 简单动态字符串（simple dynamic string， SDS）  保存字符串长度信息  O（1） 计数器等， value 最大可为512M
- list `双向`列表，可做简单消息队列、基于redis的分页功能等。
- hash  存储对象  一个key，多个value
- set         标签、抽奖
- sorted set（zset）   排序 排行榜

Redis 基于 Reactor 模式来设计开发了⾃⼰的⼀套⾼效的事件处理模型    ，`单线程模型`（更容易维护），通过I/O多路服用程序来监听客户端连接

事件驱动程序：1. 文件事件 2. 时间事件

Redis`6.0` 引⼊多线程主要是为了`提⾼⽹络 IO` 读写性能（Redis 的瓶颈主要受限于`内存和⽹络`  还是使用单线程模型来处理客户端的请求）  

过期时间 判断：过期字典（类似hash表）来保存过期时间

​                   定期删除+惰性/懒汉式删除 。

过期策略：1.惰性删除  （查询key的时候才对key进行检测，如果已经达到过期时间，则删除）2.定期删除  

### Redis 内存淘汰机制  ：

> 1. volatile-lru（least recently used） ：从已设置过期时间的数据集（server.db[i].expires）
>     中挑选最近最少使⽤的数据淘汰
> 
>2. volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
> 
> 3. volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
>
> 4. allkeys-lru（least recently used） ：当内存不⾜以容纳新写⼊数据时，在键空间中，移除
>     最近最少使⽤的 key（这个是最常⽤的）
> 
>5. allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
> 
> 6. no-eviction：禁⽌驱逐数据，也就是说当内存不⾜以容纳新写⼊数据时，新写⼊操作会报
>     错。这个应该没⼈使⽤吧！
> 
>
> 
>    4.0 版本后增加以下两种：
>
>    7.volatile-lfu（last frequently used） ：从已设置过期时间的数据集(server.db[i].expires)中
>   挑选最不经常使⽤的数据淘汰
> 
>   8.allkeys-lfu（least frequently used） ：当内存不⾜以容纳新写⼊数据时，在键空间中，移
>    除最不经常使⽤的 key  

## 事务（transaction）

MULTI（输入多条命令）， EXEC， DISCARD 和 WATCH  

`不支持roll back 因而不满足原子性`

## 存在问题：

- 缓存穿透：大量请求的key不在数据库中，直接请求了数据库（黑客恶意攻击）


   解决：1.缓存无效key（时间设短一些） 2.布隆过滤器（数据库可能数据，通过散列函数映射存储 若存在  再次查询 返回结果）

- 缓存击穿：（热点数据）key对应的数据存在，但在redis中`过期`，此时若有`大量并发请求`过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存

  ​	1.互斥锁判空       2.设置热点数据永远不过期

- 缓存雪崩：缓存在同一时间大面积`失效（缓存服务器宕机）`，直接请求了数据库

   解决	：
   
   - 数据预热；
   - 事前：Redis 高可用，主从+哨兵，Redis cluster，避免全盘崩溃。
   -  事中：本地 ehcache 缓存 + hystrix 限流&降级，避免 MySQL 被打死
   -  事后：Redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。
   
- 热点数据被大量访问： 1.利用二级缓存

     ​                                         2.备份热 key： 设置集群，请求时，根据一定规则访问集群中某个的机器

###  缓存一致性

删除缓存有两种方式：

1. 先删除缓存，再更新数据库。解决方案是使用`延迟双删`/订阅binlog。（更新完数据库后，sleep一段，再次删除缓存）。
2. 先更新数据库，再删除缓存。解决方案是消息队列或者其他`binlog同步`，引入消息队列会带来更多的问题，并`不推荐直接使用`。（成功更新完数据库，往消息队列发消息，消费到消息后再删除缓存，借助消息队列的重试机制来实现，达到最终一致性的效果。）

其他方案：针对缓存一致性要求不是很高的场景，那么只通过`设置超时时间`就可以了。

不更新缓存的原因：数据库可能更新频繁，缓存访问次数少。

## 持久化

### RDB

### AOF

虽然有AOF重写缓冲区，  aof重写还是会造成短暂的 阻塞主线程，发送信号，让主线程 进行 替换 aof文件

## 底层实现

```c++
//Redis对象由redisObject结构体表示
typedef struct redisObject {
    unsigned type:4;       // 对象的类型，包括 /* Object types */
    unsigned encoding:4;  // 底部为了节省空间，一种type的数据，可以采用不同的存储方式
    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */
    int refcount;         // 引用计数
    void *ptr;   //指向对象的底层实现数据结构
} robj;

//类型
/* The actual Redis Object */
#define OBJ_STRING 0
#define OBJ_LIST 1 
#define OBJ_SET 2
#define OBJ_ZSET 3
#define OBJ_HASH 4

/*
编码方式
*/
#define OBJ_ENCODING_RAW     /* Raw representation */ 简单动态字符串
#define OBJ_ENCODING_INT      /* Encoded as integer */ 整数
#define OBJ_ENCODING_HT       /* Encoded as hash table */ 字典
#define OBJ_ENCODING_ZIPLIST  /* Encoded as ziplist */ 压缩列表
#define OBJ_ENCODING_INTSET   /* Encoded as intset */ 整数集合
#define OBJ_ENCODING_SKIPLIST   /* Encoded as skiplist */ 跳跃表
#define OBJ_ENCODING_EMBSTR  /* Embedded sds string encoding */ embstr编码的简单动态字符串
#define OBJ_ENCODING_QUICKLIST  /* Encoded as linked list of ziplists */
```

### 底层数据结构

- SDS

  > 可以高效地执行长度计算（strlen）；
  >  可以高效地执行追加操作（append）；
  >  二进制安全；
  >
  > （预分配）加快追加操作的速度，并降低内存分配的次数  

- 双端链表

  > 实现列表
  >
  > 事务模块使用来按顺序保存输入的命令
  >
  > 服务器模块使用双端链表来保存多个客户端；
  > 订阅/发送模块使用双端链表来保存订阅模式的多个客户端；
  > 事件模块使用双端链表来保存时间事件（time event）；  

  实现：由 `listnode`（节点） 和 `list`（链表本身）构成

  可由`迭代器`从两个方向进行遍历

- 字典

  > 1.实现数据库`键空间`（与数据库对应的字典）
  >
  > 2.用作Hash类型键的其中一种底层实现

  底层实现：哈希表

  ![1](复习笔记.assets/image-20210410112940446.png)

- 跳跃表

  > 链表一种。基于并联的链表，实现简单，插入、删除、查找的复杂度均为O(logN)
  >
  > ![1](复习笔记.assets/image-20210410113522435.png)
  >
  > 实现：
  >
  > • 表头（head）：负责维护跳跃表的节点指针。
  > • 跳跃表节点：保存着元素值，以及多个层。
  > • 层：保存着指向其他元素的指针。高层的指针越过的元素数量大于等于低层的指针，为了
  > 提高查找的效率，程序总是从高层先开始访问，然后随着元素值范围的缩小，慢慢降低层
  > 次。
  > • 表尾：全部由 NULL 组成，表示跳跃表的末尾  
  >
  > 
  >
  > 每相邻两个节点增加一个指针，让指针指向下下个节点。产生若干层稀疏的链表
  
  应用：实现zset（有序数据集）
  
  > 特点：
  >
  >    1.score 值可重复。
  >
  > 2. 对比一个元素需要同时检查它的 score 和 memeber 。
  > 3.  每个节点带有高度为 1 层的后退指针，用于从表尾方向向表头方向迭代。  



### zset

编码方式：

1. ziplist

   元素数量小于128个
   所有member的长度都小于64字节

   ​	使用紧挨在一起的压缩列表节点来保存，第一个节点保存member，第二个保存score。ziplist内的集合元素按score从小到大排序，score较小的排在表头位置。

2. skiplist

   ​	zset结构体，一个zset结构同时包含一个`字典（哈希）`和一个`跳跃表`。跳跃表按score从小到大保存所有集合元素（范围性操作高效）。而字典则保存着从member到score的映射，这样就可以用`O(1)的复杂度来查找`member对应的score值。通过指针来共享相同元素的member和score

相关命令：

zadd(key, score, member)：向名称为key的zset中添加元素member，score用于排序。如果该元素已经存在，则根据score更新该元素的顺序。



#### 为何使用跳表而不用红黑树？

1. 在做`范围查找`的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找；而跳表在找到小值之后，对第1层链表进行若干步的遍历就可以实现。
2. 平衡树的`插入和删除`操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。
3. 内存占用，跳表更灵活

### 列表

实现方式：1.双端链表   2.压缩列表

​			优先使用压缩列表（省内存）

### Hash

底层实现：

- 字典
- 压缩列表



## 集群方式

+  cluster集群方案
+ 主从方案
+ 哨兵模式

# Mybatis

ORM（对象关系映射）mapper代理方式：只需要写dao接口

半自动：手动编写sql（注解或xml配置）

​		有一级缓存（Mybaits默认下开启   `SqlSession` 级别的缓存 ，最多可以缓存1024条SQL  与Spring整合后是自动关闭 ）、二级缓存（在`映射配置文件`中开启 SqlSessionFactory  `mapper`级别 以命名空间为单位创建缓存数据结构   作用域是同一个mapper的**namespace** ，不同的sqlSession可以共享  存放的是数据 ）

​       每次查询先看是否开启二级缓存-一级缓存-数据库

> - 一级缓存：map
>   - key：hashcode+sql+sql输入参数+输出参数（sql的唯一标识）
>   - value：用户信息
>   
> - 二级缓存：**可以将内存的数据写到磁盘，存在对象的序列化和反序列化**
>
>   ​						变化频率较高的sql，需要禁用二级缓存  **useCache=false**

  延迟加载：**当需要关联信息再查询**

> 工作流程：
>
> - **通过Reader对象读取Mybatis配置文件**
> - **通过SqlSessionFactoryBuilder对象创建SqlSessionFactory对象**
> - **获取当前线程的SQLSession**
> - **事务默认开启**
> - **通过SQLSession读取映射文件中的操作编号，从而读取SQL语句**
> - **提交事务**
> - **关闭资源**

好处：解决JDBC编程的问题

- 使用`连接池`管理数据库链接
- sql语句和java`代码分离`
- 参数对应

`#{}解析`传递进来的参数数据     **${}是字符串替换**

> DAO接口（Mapper接口），接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。
>
> Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement（一个<  select >标签）

## 映射

```xml
 <!--数据表的字段和JavaBean的属性名称的映射-->
 <resultMap id="userListResultMap" type="user" >
         <!-- 列名 sid,sname,
         id：要映射结果集的唯 一标识 ，称为主键
         column：结果集的列名
         property：type指定的哪个属性中
          -->
            <id property="id" column="sid"/>
           <result property="name" column="sname"/>
          <!-- result就是普通列的映射配置 -->
          

     <!-- 关联其他 map -->
      <!--
            property写的是在Student实体中写关联字段的属性变量名称
            resultMap写的是映射文件中的命名空间.id
        -->
       <association property="card" resultMap="cardNamespace.cardMap"/>
     </resultMap>


<mapper namespace="com.imooc.springboottransaction.GoodsDao">
   <!-- 对应GoodsDao中的selectForUpdate方法 -->
   <select id="selectForUpdate" resultMap="resultMapBase" parameterType="java.lang.Long">
   	select <include refid="sqlBase" /> from goods where id = #{id} for update
   </select>
   <!-- 可复用的sql模板 -->
   <sql id="sqlBase">
   	id,name,num
   </sql>
   <!-- 保存SQL语句查询结果与实体类属性的映射 -->
   <resultMap id="resultMapBase" type="com.imooc.springboottransaction.GoodsDo">
   	<id column="id" property="id" />
   	<result column="name" property="name" />
   	<result column="num" property="num" />
   </resultMap>
</mapper>

```



**在程序中调用的SQL语句是由映射文件的命令空间+sql片段的id所组成的。它内部会生成一个Statement对象的。**

## 分页：

 map装载多个参数（start、end）

```sql
 /*根据key自动找到对应Map集合的value*/
 select * from students limit #{start},#{end};

```

## 	支持多条件动态查询：

传递多参数：

- 占位符 **#{0},#{1}**
- @param注解
- map

```sql
 <!--多条件查询【动态SQL】-->
 9种动态标签：trim|where|set|foreach|if|choose|when|otherwise|bind
    <!--会自动组合成一个正常的WHERE字句-->
    <!--name值会从map中寻找-->

    <select id="findByCondition" resultMap="studentMap" parameterType="map">

        select * from students

        <where>
            <if test="name!=null">
                and name=#{name}
            </if>
            <if test="sal!=null">
                and sal < #{sal}
            </if>
        </where>

    </select>
```

### 批量删除

```sql
  <delete id="deleteByConditions" parameterType="int">

        <!-- foreach用于迭代数组元素
             open表示开始符号
             close表示结束符合
             separator表示元素间的分隔符
             item表示迭代的数组，属性值可以任意，但提倡与方法的数组名相同
             #{ids}表示数组中的每个元素值
         -->
        delete from students where id in
         <foreach collection="array" open="(" close=")" separator="," item="ids">
             #{ids}
         </foreach>

    </delete>
```

 trim标签去除逗号

​    

```sql
    <!-- mysql的uuid生成主键 -->
    <insert id="insertUser" parameterType="cn.itcast.mybatis.po.User">
        <selectKey keyProperty="id" order="BEFORE" resultType="string">
            select uuid()
        </selectKey>

        INSERT INTO USER(id,username,birthday,sex,address) VALUES(#{id},#{username},#{birthday},#{sex},#{address})
    </insert> 
```

**select LAST_INSERT_ID()就可以获取自增主键。**

可以和ehcache（管理缓存）整合

## 逆向工程

- mybatis-plus  更强大 ；支持自动生成Entity,Mapper,Mapper XML,Service,Controller文件；分页等
- mybatis-generator  数据库表（`单表`）逆向生成 代码
- 通用Mapper

## 动态连接数据库

```java
//动态配置数据库参数  
Properties properties = new Properties();  
properties.setProperty("jdbc.driver", "动态设置");  
properties.setProperty("jdbc.url", "动态设置");  
properties.setProperty("jdbc.username", "动态设置");  
properties.setProperty("jdbc.password", "动态设置");  
  
//加载mybatis配置文件和映射文件  
String resource = "mybatis/mybatis-config.xml";  
Reader reader = Resources.getResourceAsReader(resource);  
SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();  
SqlSessionFactory factory = builder.build(reader, properties);  
SqlSession session = factory.openSession();  
//获取对象  
userDsm = session.getMapper(UserDsm.class);  
......  
userDsm.addUser(...);  
```





# MongoDB

 分布式数据库 介于关系数据库和非关系数据库之间



# Spring

## 注解

元注解：

- Target 修饰对象范围
- Retention 被保留的时间长短
- @Documented 描述-javadoc  
- @Inherited 阐述了某个被标注的类型是被继承的  



标准注解：

- Override
- Deprecated
- Suppress Warnings



# 如何实现高并发系统

硬件：机器扛得住

架构设计：做好微服务的拆分（把每个独立的业务拆分开独立部署）

代码：缓存、削峰、解耦

数据库：做好读写分离、分库分表

稳定性：监控、熔断、限流、降级



### 限流

算法： 

- 计数器 ：滑动窗口

- 漏桶算法：leaky bucket、流量整形、流量控制      `限制数据的传输速率`

  ​     一个`固定容量`的桶，按照常量`固定速率`流出水滴  。水可以以`任意速率`流入漏桶 。桶满了就溢出（丢弃）。

- 令牌桶算法       限制数据的`平均传输速率`的同时还允许某种程度的`突发传输`。

  是一个存放固定容量令牌（token）的桶，按照固定速率往桶里添加令牌。

  - 令牌将按照`固定的速率`被放入令牌桶中。比如每秒放10个。
  - 桶中最多存放b个令牌，`当桶满时`，新添加的令牌`被丢弃或拒绝`。
  - 当一个n个字节大小的数据包到达，将从桶中删除n个令牌，接着数据包被发送到网络上。
  - 如果桶中的令牌不足n个，则不会删除令牌，且该数据包将被`限流（要么丢弃，要么缓冲区等待）`。

  ![1](复习笔记.assets/令牌桶算法.png)

  优点：可以在运行时控制和`调整数据处理的速率`，处理某时的`突发流量`。放令牌的频率增加可以提升整体数据处理的速度，而通过每次获取令牌的个数增加或者放慢令牌的发放速度和降低整体数据处理速度。

# 负载均衡

![1](复习笔记.assets/8e1fd656a2614d619376b5081d567d59.png)

- 随机Random: 根据随机算法，将请求随机分配到后端服务器中，请求的均匀请求依赖于随机算法.
- 最小连接数 Least Connection：通过活动来估计后端服务器的负载，把请求分配给活动连接数最小的后端服务器，算法比较智能，但是需要额外的资源维护后端服务器的连接列表。
- 最短响应时间 Least Response Time： 请求分配给平均响应时间最短的后端服务器，平均时间可以通过ping或者正常的响应时间来获取 。

# 微服务

服务注册：维护一个登记簿（服务地址）

- 客户端注册:Zookeeper 

  服务自身要负责注册与注销的工作  

- 第三方注册

  一个独立的服务Registrar负责注册与注销  

客户端发现：客户端负责查询可用服务地址，以及负载均衡的工作。  

服务端发现：需要额外的 Router 服务，请求先打到 Router，然后 Router 负责查询服务与负载均衡  

API Gateway ：一个服务器，是进入系统的唯一节点  。负责请求转发、合成和协议转换  

# 分布式

> ![img](复习笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZGMwNTIx,size_16,color_FFFFFF,t_70.png)
>
> CAP理论：不能同时做到    图中重叠的部门
>
> - Consistency： 一致性（保持数据通信）
> - Availability ：可用性（只要收到用户的请求，服务器就必须给出回应）
> - Partition tolerance ：分区容错性，区间通信可能失败，总是成立的
>
> 一般保证 CP
>
> - 基本可用  **Basically Available**
> - 柔性状态 **Soft state**
> - 最终一致性 **Eventually consistent**
>
> 



> - 分布式应用的优点：
>   - 可靠性:单个或几个系统的故障不会使整个 系统出现故障;
>   - 可扩展性：可以在需要时增加性能，通过添加更多机器，在应用程序配置中进行微小的更改，而不会有停机时间;
>   -  透明性：隐藏系统的复杂性，并将其显示为单个实体/应用程序;
> -  分布式应用的挑战
>   - 竞争条件：两个或多个机器尝试执行特定任务，实际上只需在任意给定时间由单个机器完成。例如，共享资源只能在任意给定时间由单个机器修改。
>   - 死锁：两个或多个操作等待彼此无限期完成。
>   - 不一致：数据的部分失败。
> - 通信方式
>   - 网络
>   - 共享存储

实现方式：

- Redis
- MySQL
- zookeeper





## Zookeeper：

> 分布式协调服务（完成共同目标），可用于统一命名服务（dubbo）、消息队列、服务发现，分布式锁，分布式领导选举，配置管理等  
>
> 集群角色：
>
> - Leader：一个为客户端提供读和写服务。
> - Follower：只提供读服务
> -  Observer：只读，不参与Leader选举过程，也不参与写操作的"过半写成功"策略
>
> 投票机制
>
> 原子广播

树形结构   znode数据节点存储

分类：

- 持久节点：只能通过delete删除，即显式删除才消失（主从模式中保存从节点的任务分配情况）
- 临时节点：会话终止即自动消失；临时节点的生命周期跟客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。
- 顺序节点：顺序节点可以是持久的或临时的。当一个新的znode被创建为一个顺序节点时，ZooKeeper通过将10位的序列号附加到原始名称来设置znode的路径。

会话：FIFO    服务器是否可用标识：事务标识符（zkid）





# Nginx

底层原理: 单线程＋io多路复用



# Netty

高性能、异步事件驱动的 NIO 框架     网络通信

所有 IO 操作都是异步非阻塞的， 通过 Future-Listener 机制，用户可以方便的主动获取或者通过通知机制获得 IO 操作结果  

> IO多路复用技术：多个 IO 的阻塞复用到同一个 select 的阻塞上  

提供了 SocketChannel 和 ServerSocketChannel两种不同的套接字通道实现  

Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用**堆外直接内存**进行 Socket 读写，不需要进行字节缓冲区的二次拷贝。  （组合Buffer对象）

文件传输：transferTo方法，避免循环write方式导致的内存拷贝问题

基于内存池的缓冲区重用机制  

## Reactor 线程模型  :

- Reactor单线程模型

  ​    所有的 IO 操作都在同一个 NIO 线程上面完成  

- Reactor多线程模型

     一组 NIO 线程处理 IO 操作。 有专门一个NIO 线程-Acceptor 线程用于监听服务端，接收客户端的 TCP 连接请求； 网络 IO 操作-读、写等由一个 NIO 线程池负责。  

- 主从Reactor多线程模型

  ​     一个独立的 NIO 线程池。Acceptor 接收到客户端 TCP 连接请求处理完成后（可能包含接入认证等），将新创建的SocketChannel 注册到 IO 线程池（sub reactor 线程池）的某个 IO 线程上，由它负责SocketChannel 的读写和编解码工作。 Acceptor 线程池仅仅只用于客户端的登陆、握手和安全认证，一旦链路建立成功，就将链路注册到后端 subReactor 线程池的 IO 线程上，由 IO 线程负责后续的 IO 操作。  

串行无锁化设计  ；高性能序列化框架  （Thrift  ）

# RPC

远程过程调用  微服务之间的通信

![image-20210129173314225](复习笔记.assets/image-20210129173314225.png)

> 关键技术：
> 服务发布与订阅：服务端使用 Zookeeper 注册服务地址，客户端从 Zookeeper 获取可用的服务
> 地址。

## Dubbo：

RPC框架：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现

> 工作原理：
>
> 1. 服务启动的时候，provider和consumer根据配置信息，连接到注册中心register，分别向注册中心注册和订阅服务
> 2. register根据服务订阅关系，返回provider信息到consumer，同时consumer会把provider信息缓存到本地。如果信息有变更，consumer会收到来自register的推送
> 3. consumer生成代理对象，同时根据负载均衡策略，选择一台provider，同时定时向monitor记录接口的调用次数和时间信息
> 4. 拿到代理对象之后，consumer通过代理对象发起接口调用
> 5. provider收到请求后对数据进行反序列化，然后通过代理调用具体的接口实现
>
> ![1](复习笔记.assets/v2-23f0f4176969006638c8c8aaa36a7322_720w.jpg)

负载均衡策略：

集群容错：

# 消息队列

Spring中两个消息框架：Spring Messaging 和  Spring Cloud Stream

没有事务，但 有保证 可靠性投递

## RabbitMQ  ：

高级消息队列协议  的实现



## RocketMQ

消息失败后 会触发 重试机制，若多次重试失败 进入 死信 队列

## Kafka

消息服务和事件的统一调度  。高吞吐量、分布式、基于发布/订阅的消息系统  

数据文件分段 segment（顺序读写、分段命令、二分查找）  

数据文件索引（分段索引、 稀疏存储）  

负载均衡 批量发送 压缩 



# Elasticsearch （es）

 是一个基于 Lucene 的、支持全文索引的**分布式**存储和索引引擎，主要负责将日志索引并存储起                  									来，方便业务方检索查询  。

倒排索引，分片和副本是什么？



# Shiro：

一个强大且易用的Java`安全框架`,执行身份验证、授权、密码和会话管理

# SSO

`单点登录`  统一认证和授权

同域下：Cookie设置为顶域；Session共享，如：Spring-Session

不同域：	CAS流程

https://developer.aliyun.com/article/636281

https://juejin.cn/post/6844903845424971783

多设备登录： 除了使用userID，使用loginID（x# + userID ：X：表示设备号）

​                         多个token

# 补充

 

## docker：

镜像、容器、仓库

​     搭建、发送、运行

![image-20210526110301359](复习笔记.assets/image-20210526110301359.png)



## K8S: 

集群：一个Master节点（主节点）、一群Node节点（计算节点）

![1](复习笔记.assets/23f90afc93964ad6bf7cc6aa15a29330.png)

Master(负责管理和控制)节点包括API Server、Scheduler、Controller manager、etcd。

API Server是整个系统的对外接口，供客户端和其它组件调用，相当于“营业厅”。

Scheduler负责对集群内部的资源进行调度，相当于“调度室”。

Controller manager负责管理控制器，相当于“大总管”。

**Node节点。**（工作负载节点）

![1](复习笔记.assets/0c3886c04a744cee93f7f0acb3dd9708.png)

Docker:创建容器的。

Kubelet，主要负责监视指派到它所在Node上的Pod，包括创建、修改、监控、删除等。

Kube-proxy，主要负责为Pod对象提供代理。

Fluentd，主要负责日志收集、存储与查询。 
